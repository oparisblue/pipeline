(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };

  // src/app/nodes/index.ts
  var nodes_exports = {};
  __export(nodes_exports, {
    NodeAdd: () => NodeAdd,
    NodeBrightness: () => NodeBrightness,
    NodeChannels: () => NodeChannels,
    NodeCrop: () => NodeCrop,
    NodeDownload: () => NodeDownload,
    NodeFlipImageHorizontal: () => NodeFlipImageHorizontal,
    NodeFlipImageVertical: () => NodeFlipImageVertical,
    NodeGrayscale: () => NodeGrayscale,
    NodeHueRotate: () => NodeHueRotate,
    NodeImage: () => NodeImage,
    NodeImageTransformation: () => NodeImageTransformation,
    NodeInvert: () => NodeInvert,
    NodeMultiply: () => NodeMultiply,
    NodeSplit: () => NodeSplit,
    NodeTakePhoto: () => NodeTakePhoto,
    NodeThreshold: () => NodeThreshold
  });

  // src/app/types/index.ts
  var types_exports = {};
  __export(types_exports, {
    TypeAny: () => TypeAny,
    TypeImage: () => TypeImage,
    TypeNumber: () => TypeNumber,
    TypeUnknown: () => TypeUnknown
  });

  // src/app/DataType.ts
  var DataType = class {
    /**
    * The value represented by the data type.
    * This should always be interacted with via .getValue() / .setValue(), to protect the
    * invarient that it is always of the correct data type.
    */
    value;
    control;
    constructor(initialValue = null) {
      this.value = initialValue == null ? this.defaultValue() : this.cast(initialValue);
    }
    /**
    * Checks if it is possible to cast from another data type to this one.
    * @return {boolean} `true` if a cast is possible, `false` if it is not.
    */
    canCast(other) {
      try {
        this.cast(other.getValue());
        return true;
      } catch (e) {
        return false;
      }
    }
    /**
    * Get the current value stored in this data type.
    */
    getValue() {
      return this.value;
    }
    /**
    * Update the value of this data type.
    * @param newValue The new value to store. If it is not of this type, then a cast will be attempted.
    * @param type The current type of the new value.
    * @throws {TypeError} If the attempted cast is not possible.
    */
    setValue(newValue, _type) {
      this.value = this.cast(newValue);
    }
    /**
    * The value returned by `getHexColour` can change depending on various factors. However, the colour used for drawing
    * lines and plugs should always remain the same - hence, they use the value returned by this method.
    * Typically, the two values are always the same, but this allows for them to be different.
    */
    getActualHexColour() {
      return this.getHexColour();
    }
    /**
    * Perform one-off setup tasks for the preview rendered at the top of the node.
    */
    doPreviewSetup(_element) {
    }
    /**
    * Update the disabled state / value of the data type's control.
    */
    updateControl(_disabled, _value) {
    }
    /**
    * Render a preview of this data type to be shown at the top of the node.
    */
    doPreviewRender(_element) {
    }
  };

  // src/app/types/TypeUnknown.ts
  var TypeUnknown = class extends DataType {
    cast(other) {
      return other;
    }
    defaultValue() {
      return null;
    }
    getHexColour() {
      return "#FFC107";
    }
    getName() {
      return "Anything";
    }
    makeControl(_point, _disabled) {
      return document.createElement("span");
    }
    doPreviewRender(element) {
      element.innerHTML = `<div class="previewEmpty"></div>`;
    }
  };

  // src/app/types/TypeAny.ts
  var TypeAny = class extends DataType {
    otherType = new TypeUnknown();
    cast(other) {
      return other;
    }
    defaultValue() {
      return null;
    }
    getActualHexColour() {
      return "#FFC107";
    }
    makeControl(_point, _disabled) {
      this.control = document.createElement("span");
      this.changeControlText();
      return this.control;
    }
    // The plan here is to save the type of the other object whenever it is passed in,
    // and then just return its values / perform its commands to generate the colour,
    // name and preview.
    // Note that this approach also allows for type data to flow through multiple sets
    // of Any types.
    setValue(newValue, type) {
      super.setValue(newValue, type);
      this.otherType = type;
      this.changeControlText();
    }
    doPreviewRender(element) {
      element.innerHTML = "";
      element.setAttribute("class", "preview");
      this.otherType.doPreviewSetup(element);
      this.otherType.doPreviewRender(element);
    }
    getHexColour() {
      return this.otherType.getHexColour();
    }
    getName() {
      return this.otherType.getName();
    }
    changeControlText() {
      this.control.innerHTML = this.getName();
      this.control.style.color = this.getHexColour();
    }
    /**
    * Get the _actual_ data type of the value stored in this Any node.
    */
    getOtherType() {
      return this.otherType;
    }
  };

  // src/app/types/TypeImage.ts
  var TypeImage = class extends DataType {
    cast(other) {
      if (other == null)
        return other;
      if (!(other instanceof Image))
        throw new TypeError("Could not convert to an image!");
      if (!other.complete || other.naturalHeight == 0)
        return null;
      return other;
    }
    defaultValue() {
      return null;
    }
    getHexColour() {
      return "#E91E63";
    }
    getName() {
      return "Image";
    }
    makeControl(_point, disabled) {
      this.control = document.createElement("span");
      this.control.innerHTML = this.makeImageDescription(null);
      this.control.style.color = this.getHexColour();
      if (disabled)
        this.control.classList.add("disabledControl");
      return this.control;
    }
    updateControl(disabled, value) {
      this.control.setAttribute("class", disabled ? "disabledControl" : "");
      this.control.innerHTML = this.makeImageDescription(value);
    }
    makeImageDescription(img) {
      return `<i class="mdi mdi-file-image"></i> ${img == null ? "No Image" : `Image (${img.width} &times; ${img.height})`}`;
    }
    doPreviewSetup(element) {
      element.classList.add("previewImage");
    }
    doPreviewRender(element) {
      let img = this.getValue();
      element.innerHTML = "";
      if (img == null) {
        element.innerHTML = `<div class="previewEmpty"></div>`;
      } else {
        let displayImg = new Image();
        displayImg.src = img.src;
        displayImg.draggable = false;
        element.appendChild(displayImg);
      }
    }
    /**
    * Apply a transformation to the image contained in this type, and get a _new_ image back.
    * @param {ImageTransformationFunction} transformation A lambda that takes a canvas rendering context with the
    * image already drawn to it, as well the canvas itself, and a copy of the image. In this lambda, you can then
    * change the canvas state however you want, and what is on it at the end will become the new image value!
    * @return {TypeImage} A new image type containing the result of applying that transformation.
    */
    performTransformation(transformation) {
      let img = this.getValue();
      if (img == null)
        return null;
      let canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      let ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      transformation(canvas, ctx, img);
      let newImg = new Image();
      newImg.src = canvas.toDataURL("image/png");
      return newImg;
    }
  };

  // src/app/types/TypeNumber.ts
  var TypeNumber = class extends DataType {
    cast(other) {
      if (other === true || other === false)
        return other + 0;
      if (other === "" || other == null)
        return this.defaultValue();
      let number = parseFloat(other);
      if (isNaN(number))
        throw new TypeError("Could not convert to a number!");
      return number;
    }
    defaultValue() {
      return 0;
    }
    getHexColour() {
      return "#03A9F4";
    }
    getName() {
      return "Number";
    }
    makeControl(point, disabled) {
      let input = document.createElement("input");
      input.type = "number";
      input.value = this.getValue();
      input.disabled = disabled;
      input.oninput = () => {
        point.setValue(input.value, true);
      };
      input.onblur = () => {
        input.value = this.getValue();
      };
      this.control = input;
      return input;
    }
    updateControl(disabled, value) {
      let input = this.control;
      input.disabled = disabled;
      input.value = value;
    }
    doPreviewSetup(element) {
      element.classList.add("previewNumber");
    }
    doPreviewRender(element) {
      element.innerHTML = `<div>${this.getValue().toLocaleString("en-US")}</div>`;
    }
  };

  // src/app/IOSide.ts
  var IOSide = /* @__PURE__ */ ((IOSide2) => {
    IOSide2[IOSide2["Input"] = 0] = "Input";
    IOSide2[IOSide2["Output"] = 1] = "Output";
    return IOSide2;
  })(IOSide || {});

  // src/app/ConnectionPoint.ts
  var ConnectionPoint = class {
    name;
    description;
    type;
    node;
    link = null;
    // The X and Y position of the center of the connection point (where the lines are drawn from)
    x;
    y;
    side;
    constructor(name, description, type, node) {
      this.name = name;
      this.description = description;
      this.type = type;
      this.node = node;
    }
    getName() {
      return this.name;
    }
    getDescription() {
      return this.description;
    }
    /**
    * Set the value stored in this connection point, casting the type (if possible).
    * @param {any} newValue The new value for the connection point.
    * @param {boolean} updateNode Optional (default `false`). When `true`, this updates the node, when `false` it doesn't.
    * @param {boolean} updateInlets Optional (default `false`). If this and `updateNode` are both true, then the value / disabled state of inlet controls is also updated
    * @param {DataType} otherType Optional (default `TypeUnknown`). The original type of the value. Note that this does not have to be provided, and can often be successfuly calculated instead.
    * @throws {TypeError} If the attempted cast is not possible.
    */
    setValue(newValue, updateNode = false, updateInlets = false, otherType = null) {
      let type = new TypeUnknown();
      if (otherType != null)
        type = otherType;
      else if (this.side == 0 /* Input */ && this.hasLink())
        type = this.link.getType();
      this.type.setValue(newValue, type);
      if (updateNode)
        this.node.update(updateInlets);
    }
    getValue() {
      return this.type.getValue();
    }
    getType() {
      return this.type;
    }
    /**
    * Update the node on the other end of this connection point, if such a link exists.
    */
    updateLinkedNode() {
      if (this.link != null) {
        this.link.setValue(this.getValue(), true, true);
      }
    }
    setLinkedNode(link) {
      this.link = link;
    }
    getLinkedNode() {
      return this.link;
    }
    /**
    * @return `true` if this connection point is linked to another connection point; `false` otherwise.
    */
    hasLink() {
      return this.link != null;
    }
    /**
    * @return The node this connection point belongs to.
    */
    getNode() {
      return this.node;
    }
  };

  // src/app/previews/index.ts
  var previews_exports = {};
  __export(previews_exports, {
    CameraFeedState: () => CameraFeedState,
    PreviewConnectionPoint: () => PreviewConnectionPoint,
    PreviewCrop: () => PreviewCrop,
    PreviewFromCamera: () => PreviewFromCamera
  });

  // src/app/previews/PreviewConnectionPoint.ts
  var PreviewConnectionPoint = class {
    point;
    element;
    constructor(point) {
      this.point = point;
    }
    setup(element) {
      this.element = element;
      this.point.getType().doPreviewSetup(element);
    }
    render() {
      this.point.getType().doPreviewRender(this.element);
      this.point.getNode().updatePlugPositions();
    }
  };

  // src/app/previews/PreviewCrop.ts
  var PreviewCrop = class {
    node;
    element;
    canvas = null;
    image = new Image();
    constructor(node) {
      this.node = node;
      this.image.draggable = false;
    }
    setup(element) {
      this.element = element;
      this.element.classList.add("previewCrop");
    }
    render() {
      let img = this.node.inlets[0].getValue();
      if (img == null) {
        this.element.innerHTML = `<div class="previewEmpty"></div>`;
        this.canvas = null;
      } else {
        this.image.src = img.src;
        if (this.canvas == null) {
          this.element.innerHTML = "";
          this.canvas = document.createElement("canvas");
          this.element.appendChild(this.canvas);
          this.element.appendChild(this.image);
        }
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        let x0 = this.node.inlets[1].getValue();
        let y0 = this.node.inlets[2].getValue();
        let x1 = this.node.inlets[3].getValue();
        let y1 = this.node.inlets[4].getValue();
        let ctx = this.canvas.getContext("2d");
        ctx.rect(0, 0, this.canvas.width, this.canvas.height);
        ctx.moveTo(x0, y0);
        ctx.rect(x0, y0, x1 - x0, y1 - y0);
        ctx.fillStyle = "#000B";
        ctx.fill("evenodd");
      }
      this.node.updatePlugPositions();
    }
  };

  // src/app/previews/PreviewFromCamera.ts
  var PreviewFromCamera = class {
    point;
    element;
    // Should the preview display the live feed from the camera?
    live = true;
    // Keep track of the camera stream, so that we can close it when we need to
    stream;
    // The video element in which the live feed is shown
    video;
    constructor(point) {
      this.point = point;
    }
    setup(element) {
      this.element = element;
      this.element.classList.add("previewVideo");
      this.startLiveFeed();
    }
    render() {
    }
    /**
    * Toggle whether we show the live feed or not.
    * If we are transitioning from live to still, also send the still image to the outlet.
    */
    takePhoto() {
      if (this.live) {
        let rect = this.video.getBoundingClientRect();
        let canvas = document.createElement("canvas");
        canvas.width = this.video.videoWidth;
        canvas.height = this.video.videoHeight;
        let ctx = canvas.getContext("2d");
        ctx.drawImage(this.video, 0, 0);
        let img = new Image();
        img.src = canvas.toDataURL("image/png");
        img.onload = () => {
          this.point.setValue(img, true);
        };
        this.element.innerHTML = "";
        canvas.setAttribute("style", `width:${rect.width}px; height:${rect.height}px;`);
        this.element.appendChild(canvas);
        this.endStream();
        this.point.getNode().updatePlugPositions();
        return 1 /* STILL */;
      } else {
        let rect = this.element.getBoundingClientRect();
        this.element.style.width = rect.width + "px";
        this.element.style.height = rect.height - 1 + "px";
        this.live = true;
        this.startLiveFeed();
        return 0 /* LIVE */;
      }
    }
    /**
    * End the camera stream - e.g. to save resources and turn off the camera light
    */
    endStream() {
      this.stream.getTracks().forEach((x) => x.stop());
      this.live = false;
    }
    /**
    * Start the live camera feed.
    */
    startLiveFeed() {
      if (this.live) {
        this.video = document.createElement("video");
        this.video.autoplay = true;
        this.video.width = 300;
        this.element.innerHTML = "";
        this.element.appendChild(this.video);
        this.point.getNode().updatePlugPositions();
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          this.stream = stream;
          this.video.srcObject = this.stream;
          this.video.onplaying = () => {
            this.point.getNode().updatePlugPositions();
          };
        });
      }
    }
  };
  var CameraFeedState = /* @__PURE__ */ ((CameraFeedState2) => {
    CameraFeedState2[CameraFeedState2["LIVE"] = 0] = "LIVE";
    CameraFeedState2[CameraFeedState2["STILL"] = 1] = "STILL";
    return CameraFeedState2;
  })(CameraFeedState || {});

  // src/app/utils/Angles.ts
  function radians(degrees) {
    return degrees * Math.PI / 180;
  }

  // src/app/utils/IterateEnum.ts
  function* iterateEnum(enumerable) {
    for (let i in enumerable) {
      if (isNaN(parseFloat(i)))
        yield enumerable[i];
    }
  }

  // src/app/utils/Math.ts
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  // src/app/NodeElement.ts
  var NodeElement = class {
    inlets = [];
    outlets = [];
    dragOffsetX;
    dragOffsetY;
    name = "";
    description = "No summary available.";
    help = "No help available.";
    path = ["Misc"];
    appearsInAddGUI = true;
    topUI = null;
    bottomUI = null;
    preview;
    element;
    previewPane;
    // Builder design pattern for creating new node types, e.g.
    //     this.setProperties({name: "Add", description: "Add two numbers together", path: "Math/Basic"}).addInlet(...).addInlet(...).addOutlet(...).build();
    /**
    * Set up the basic details for the node.
    * @param {any} properties A JSON object that can contain:
    *   * `name`: a string which represents the name of the node. This is shown when searching for the node, and at the top of each instance of it.
    *   * `description`: a string which discusses what the node does. Shown when the user hovers over the node when searching, or in the summary section of its help.
    *   * `help`: a string (which can contain HTML) of detailed help for this node. Shown when the user clicks its help button.
    *   * `path`: a string like "Math/Basic", representing the category path the user must traverse to find the node in the search widget.
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    setProperties(properties) {
      if ("name" in properties)
        this.name = properties.name;
      if ("description" in properties)
        this.description = properties.description;
      if ("help" in properties)
        this.help = properties.help;
      if ("path" in properties)
        this.path = (properties.path || "Misc").replace(/\/$/, "").split("/");
      return this;
    }
    /**
    * Add an inlet to the node's definition.
    * @param {any} properties A JSON object that must contain:
    *   * `name`: the name of the inlet, as shown on the node UI
    *   * `type`: a new instance of a {@link DataType} object like TypeNumber, TypeString, etc.
    *
    * Optionally, it can also contain:
    *   * `description`: a description of what the inlet does, shown when hovering over the inlet and in the help screen for the node.
    *
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    addInlet(properties) {
      this.inlets.push(new ConnectionPoint(properties.name, properties.description || "", properties.type, this));
      return this;
    }
    /**
    * Add an outlet to the node's definition.
    * @param {any} properties A JSON object that must contain:
    *   * `name`: the name of the outlet, as shown on the node UI
    *   * `type`: a new instance of a {@link DataType} object like TypeNumber, TypeString, etc.
    *
    * Optionally, it can also contain:
    *   * `description`: a description of what the outlet does, shown when hovering over the outlet and in the help screen for the node.
    *
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    addOutlet(properties) {
      this.outlets.push(new ConnectionPoint(properties.name, properties.description || "", properties.type, this));
      return this;
    }
    /**
    * Set the preview strategy that this node should use.
    * @param {Preview | ConnectionPoint} preview A preview strategy to use, or a connection point (in which case PreviewConnectionPoint is used automatically).
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    setPreview(preview) {
      if (preview instanceof ConnectionPoint)
        this.preview = new PreviewConnectionPoint(preview);
      else
        this.preview = preview;
      return this;
    }
    /**
    * Set the UI elements to be shown at the top of the node
    * @param {HTMLElement} ui The element to add, or `null` to remove any added element.
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    setTopUI(ui) {
      this.topUI = ui;
      return this;
    }
    /**
    * Set the UI elements to be shown at the bottom of the node
    * @param {HTMLElement} ui The element to add, or `null` to remove any added element.
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    setBottomUI(ui) {
      this.bottomUI = ui;
      return this;
    }
    /**
    * Hide this element in the node add GUI.
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    hideInAddGUI() {
      this.appearsInAddGUI = false;
      return this;
    }
    /**
    * Hide this element in the node add GUI.
    * @return {NodeElement} The current node, so that you can chain configuration functions.
    */
    showInAddGUI() {
      this.appearsInAddGUI = true;
      return this;
    }
    /**
    * Mark the node as complete, creating its element and running the setup functions.
    * @throws {InvalidStateError} If the name of the node has not been set via e.g. `setProperties`.
    */
    build() {
      if (this.name == "") {
        throw new Error("All nodes must declare a name!");
      }
      this.inlets.forEach((x) => {
        x.side = 0 /* Input */;
      });
      this.outlets.forEach((x) => {
        x.side = 1 /* Output */;
      });
      this.element = document.createElement("div");
      this.element.classList.add("node");
      let title = document.createElement("div");
      title.classList.add("title");
      let deleteButton = document.createElement("div");
      deleteButton.innerHTML = `<i class="mdi mdi-delete"></i>`;
      deleteButton.classList.add("nodeDelete");
      deleteButton.title = "Delete Node";
      deleteButton.onclick = () => {
        this.onBeforeDelete();
        for (let inlet of this.inlets) {
          if (inlet.hasLink()) {
            inlet.getLinkedNode().setLinkedNode(null);
            application.connections.removeLine(inlet);
          }
        }
        for (let outlet of this.outlets) {
          if (outlet.hasLink()) {
            let linkedNode = outlet.getLinkedNode();
            linkedNode.setLinkedNode(null);
            linkedNode.setValue(linkedNode.getType().defaultValue(), true, true);
            application.connections.removeLine(outlet);
          }
        }
        this.element.remove();
        application.updateState();
      };
      title.appendChild(deleteButton);
      title.appendChild(document.createTextNode(this.name));
      title.onmousedown = () => {
        let rect = title.getBoundingClientRect();
        this.dragOffsetX = application.getMouseX() - rect.left;
        this.dragOffsetY = application.getMouseY() - rect.top;
        application.draggingNode = this;
      };
      this.element.appendChild(title);
      this.previewPane = document.createElement("div");
      this.previewPane.classList.add("preview");
      this.element.appendChild(this.previewPane);
      if (this.topUI != null) {
        this.element.appendChild(this.topUI);
      }
      let patchboard = document.createElement("table");
      let points = [this.inlets, this.outlets];
      for (let side of iterateEnum(IOSide)) {
        for (let point of points[side]) {
          let empty = document.createElement("td");
          let plugColumn = document.createElement("td");
          let plug = document.createElement("div");
          plug.classList.add("plug");
          plug.style.borderColor = point.getType().getActualHexColour();
          plug.addEventListener("mousedown", () => {
            application.connections.makeConnection(point);
          });
          plug.addEventListener("mouseup", () => {
            application.connections.makeConnection(point);
          });
          plugColumn.appendChild(plug);
          let label = document.createElement("td");
          label.title = point.getDescription();
          label.innerText = point.getName() + ":";
          let control = document.createElement("td");
          control.appendChild(point.getType().makeControl(point, side == 1 /* Output */));
          let row = document.createElement("tr");
          row.appendChild(side == 0 /* Input */ ? plugColumn : empty);
          row.appendChild(label);
          row.appendChild(control);
          row.appendChild(side == 1 /* Output */ ? plugColumn : empty);
          patchboard.appendChild(row);
        }
        if (side == 0 /* Input */) {
          let divider = document.createElement("tr");
          divider.innerHTML = `<td colspan="4"><div class="divider"></div></td>`;
          patchboard.appendChild(divider);
        }
      }
      this.element.appendChild(patchboard);
      if (this.bottomUI != null) {
        this.element.appendChild(this.bottomUI);
      }
    }
    /**
    * Update the X and Y positions of the plugs in this node, so that lines between them are drawn correctly.
    */
    updatePlugPositions() {
      let points = [this.inlets, this.outlets];
      let plugs = this.element.querySelectorAll(".plug");
      if (plugs.length == 0)
        return;
      for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points[i].length; j++) {
          let point = points[i][j];
          let rect = plugs[i * points[0].length + j].getBoundingClientRect();
          point.x = rect.left + rect.width / 2;
          point.y = rect.top + rect.height / 2;
        }
      }
    }
    /**
    * Re-calculate the value of this node, and then update the preview and the nodes that come after this one.
    */
    update(updateInlets = false) {
      new Promise((resolve, reject) => {
        this.apply(resolve, reject);
      }).then(() => {
        this.preview.render();
        if (updateInlets) {
          for (let inlet of this.inlets) {
            inlet.getType().updateControl(inlet.hasLink(), inlet.getValue());
          }
        }
        for (let outlet of this.outlets) {
          outlet.updateLinkedNode();
          outlet.getType().updateControl(true, outlet.getValue());
        }
      }).catch(() => {
      });
    }
    setupPreview() {
      this.preview.setup(this.previewPane);
      this.preview.render();
    }
    /**
    * Gets called just before the node gets deleted, to do any required cleanup tasks
    */
    onBeforeDelete() {
    }
    // Getters
    getElement() {
      return this.element;
    }
    getName() {
      return this.name;
    }
    getDescription() {
      return this.description;
    }
    getHelp() {
      return this.help;
    }
    getPath() {
      return this.path;
    }
    isNodeAddable() {
      return this.appearsInAddGUI;
    }
  };

  // src/app/Registry.ts
  var registry;
  var fileHandlerRegistry;
  var downloaders;
  function register(constructor) {
    if (registry == void 0)
      registry = [];
    registry.push(constructor);
  }
  function fileFormat(magicNumbers, contentType, extension) {
    return (constructor) => {
      if (fileHandlerRegistry == void 0)
        fileHandlerRegistry = [];
      fileHandlerRegistry.push([[magicNumbers, contentType, extension], constructor]);
    };
  }
  function downloadStrategy(constructor) {
    if (downloaders == void 0)
      downloaders = [];
    downloaders.push(new constructor());
  }

  // src/app/nodes/Image/Creation/NodeTakePhoto.ts
  var NodeTakePhoto = class extends NodeElement {
    constructor() {
      super();
      let takePhotoButton = document.createElement("div");
      takePhotoButton.classList.add("liveMediaButton");
      takePhotoButton.innerHTML = `<i class="mdi mdi-camera"></i>`;
      takePhotoButton.onclick = () => {
        let status = this.preview.takePhoto();
        takePhotoButton.innerHTML = `<i class="mdi mdi-${status == 0 /* LIVE */ ? "camera" : "refresh"}"></i>`;
      };
      this.setProperties({ name: "Take Photo", description: "Take a photo using your webcam", path: "Image/Creation" }).addOutlet({ name: "Photo", description: "The photo", type: new TypeImage() }).setPreview(new PreviewFromCamera(this.outlets[0])).setTopUI(takePhotoButton).build();
    }
    apply(resolve, _reject) {
      resolve();
    }
    onBeforeDelete() {
      this.preview.endStream();
    }
  };
  NodeTakePhoto = __decorateClass([
    register
  ], NodeTakePhoto);

  // src/app/nodes/Image/NodeImageTransformation.ts
  var NodeImageTransformation = class extends NodeElement {
    constructor(name, description, subfolder = "") {
      super();
      this.setProperties({ name, description, path: "Image" + subfolder }).addInlet({ name: "Image", description: "The initial image", type: new TypeImage() }).addOutlet({ name: "Output", description: "The transformed image", type: new TypeImage() }).setPreview(this.outlets[0]).build();
    }
    apply(resolve, _reject) {
      let img = this.inlets[0].getType().performTransformation(this.transformation);
      if (img == null) {
        this.outlets[0].setValue(null);
        resolve();
      } else {
        img.onload = () => {
          this.outlets[0].setValue(img);
          resolve();
        };
      }
    }
  };

  // src/app/nodes/Image/Effects/NodeBrightness.ts
  var NodeBrightness = class extends NodeImageTransformation {
    constructor() {
      super("Brightness", "Brighten or darken an image", "/Effects");
      this.addInlet({ name: "Amount", description: "The amount to brighten (or, if negative, darken) the image by", type: new TypeNumber() }).build();
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      let amount = this.inlets[1].getValue();
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] += amount;
        pixels[i + 1] += amount;
        pixels[i + 2] += amount;
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeBrightness = __decorateClass([
    register
  ], NodeBrightness);

  // src/app/nodes/Image/Effects/NodeGrayscale.ts
  var NodeGrayscale = class extends NodeImageTransformation {
    constructor() {
      super("Grayscale", "Convert an image to black and white (grayscale)", "/Effects");
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = pixels[i + 1] = pixels[i + 2] = Math.round((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeGrayscale = __decorateClass([
    register
  ], NodeGrayscale);

  // src/app/nodes/Image/Effects/NodeHueRotate.ts
  var NodeHueRotate = class extends NodeImageTransformation {
    matrix;
    constructor() {
      super("Hue Rotate", "Rotate the colours of an image", "/Effects");
      this.addInlet({
        name: "Amount",
        description: "The amount to rotate the colour space",
        type: new TypeNumber()
      }).build();
      this.matrix = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
      ];
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      let amount = this.inlets[1].getValue() % 360;
      this.setHueRotation(amount);
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const rx = clamp(r * this.matrix[0][0] + g * this.matrix[0][1] + b * this.matrix[0][2], 0, 255);
        const gx = clamp(r * this.matrix[1][0] + g * this.matrix[1][1] + b * this.matrix[1][2], 0, 255);
        const bx = clamp(r * this.matrix[2][0] + g * this.matrix[2][1] + b * this.matrix[2][2], 0, 255);
        pixels[i] = rx;
        pixels[i + 1] = gx;
        pixels[i + 2] = bx;
      }
      ctx.putImageData(data, 0, 0);
    };
    setHueRotation(degrees) {
      const cosA = Math.cos(radians(degrees));
      const sinA = Math.sin(radians(degrees));
      this.matrix[0][0] = cosA + (1 - cosA) / 3;
      this.matrix[0][1] = 1 / 3 * (1 - cosA) - Math.sqrt(1 / 3) * sinA;
      this.matrix[0][2] = 1 / 3 * (1 - cosA) + Math.sqrt(1 / 3) * sinA;
      this.matrix[1][0] = 1 / 3 * (1 - cosA) + Math.sqrt(1 / 3) * sinA;
      this.matrix[1][1] = cosA + 1 / 3 * (1 - cosA);
      this.matrix[1][2] = 1 / 3 * (1 - cosA) - Math.sqrt(1 / 3) * sinA;
      this.matrix[2][0] = 1 / 3 * (1 - cosA) - Math.sqrt(1 / 3) * sinA;
      this.matrix[2][1] = 1 / 3 * (1 - cosA) + Math.sqrt(1 / 3) * sinA;
      this.matrix[2][2] = cosA + 1 / 3 * (1 - cosA);
    }
  };
  NodeHueRotate = __decorateClass([
    register
  ], NodeHueRotate);

  // src/app/nodes/Image/Effects/NodeInvert.ts
  var NodeInvert = class extends NodeImageTransformation {
    constructor() {
      super("Invert", "Invert the colours of the image", "/Effects");
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 255 - pixels[i];
        pixels[i + 1] = 255 - pixels[i + 1];
        pixels[i + 2] = 255 - pixels[i + 2];
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeInvert = __decorateClass([
    register
  ], NodeInvert);

  // src/app/nodes/Image/Effects/NodeThreshold.ts
  var NodeThreshold = class extends NodeImageTransformation {
    constructor() {
      super("Threshold", "Threshold an image - e.g. every pixel under the threshold value is black, every pixel over it is white", "/Effects");
      let initialValue = new TypeNumber();
      initialValue.setValue(128, null);
      this.addInlet({ name: "Threshold", description: "The threshold value", type: initialValue }).build();
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      let threshold = this.inlets[1].getValue();
      for (let i = 0; i < pixels.length; i += 4) {
        let avg = Math.round((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
        pixels[i] = pixels[i + 1] = pixels[i + 2] = avg < threshold ? 0 : 255;
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeThreshold = __decorateClass([
    register
  ], NodeThreshold);

  // src/app/nodes/Image/NodeChannels.ts
  var NodeChannels = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Channels", description: "Split an image into its red, green and blue channels", path: "Image" }).addInlet({ name: "Image", description: "The initial image", type: new TypeImage() }).addOutlet({ name: "Red", description: "The red channel", type: new TypeImage() }).addOutlet({ name: "Green", description: "The green channel", type: new TypeImage() }).addOutlet({ name: "Blue", description: "The blue channel", type: new TypeImage() }).setPreview(this.inlets[0]).build();
    }
    apply(resolve, reject) {
      let imgType = this.inlets[0].getType();
      let img = this.inlets[0].getValue();
      let channelOutlets = this.outlets;
      console.log(channelOutlets);
      if (img == null) {
        this.outlets[0].setValue(null);
        this.outlets[1].setValue(null);
        this.outlets[2].setValue(null);
      } else {
        let loaded = 0;
        for (let i = 0; i < 3; i++) {
          let newImg = imgType.performTransformation((canvas, ctx, _img) => {
            let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let pixels = data.data;
            for (let j = 0; j < pixels.length; j += 4) {
              let colour = pixels[j + i];
              pixels[j] = pixels[j + 1] = pixels[j + 2] = 0;
              pixels[j + i] = colour;
            }
            ctx.putImageData(data, 0, 0);
          });
          newImg.onload = () => {
            channelOutlets[i].setValue(newImg);
            if (++loaded == 3) {
              resolve();
            }
          };
        }
      }
    }
  };
  NodeChannels = __decorateClass([
    register
  ], NodeChannels);

  // src/app/nodes/Image/NodeCrop.ts
  var NodeCrop = class extends NodeImageTransformation {
    constructor() {
      super("Crop", "Crop an image");
      this.addInlet({ name: "Top-Left X", description: "The X (horizontal) position of crop rectangle's top-left corner", type: new TypeNumber() }).addInlet({ name: "Top-Left Y", description: "The Y (vertical) position of crop rectangle's top-left corner", type: new TypeNumber() }).addInlet({ name: "Bottom-Right X", description: "The X (horizontal) position of crop rectangle's bottom-right corner", type: new TypeNumber() }).addInlet({ name: "Bottom-Right Y", description: "The Y (vertical) position of crop rectangle's bottom-right corner", type: new TypeNumber() }).setPreview(new PreviewCrop(this)).build();
    }
    transformation = (canvas, ctx, img) => {
      if (img == null)
        return;
      if (this.inlets[3].getValue() == 0 && this.inlets[4].getValue() == 0) {
        this.inlets[3].setValue(img.width);
        this.inlets[4].setValue(img.height);
      }
      let x0 = this.inlets[1].getValue();
      let y0 = this.inlets[2].getValue();
      let x1 = this.inlets[3].getValue();
      let y1 = this.inlets[4].getValue();
      canvas.width = x1 - x0;
      canvas.height = y1 - y0;
      ctx.drawImage(img, x0, y0, x1 - x0, y1 - y0, 0, 0, canvas.width, canvas.height);
    };
  };
  NodeCrop = __decorateClass([
    register
  ], NodeCrop);

  // src/app/nodes/Image/NodeFlipImageHorizontal.ts
  var NodeFlipImageHorizontal = class extends NodeImageTransformation {
    constructor() {
      super("Flip Image Horizontally", "Flips an image horizontally (across the X axis)");
    }
    transformation = (canvas, ctx, img) => {
      ctx.scale(-1, 1);
      ctx.drawImage(img, -canvas.width, 0);
    };
  };
  NodeFlipImageHorizontal = __decorateClass([
    register
  ], NodeFlipImageHorizontal);

  // src/app/nodes/Image/NodeFlipImageVertical.ts
  var NodeFlipImageVertical = class extends NodeImageTransformation {
    constructor() {
      super("Flip Image Vertically", "Flips an image vertically (across the Y axis)");
    }
    transformation = (canvas, ctx, img) => {
      ctx.scale(1, -1);
      ctx.drawImage(img, 0, -canvas.height);
    };
  };
  NodeFlipImageVertical = __decorateClass([
    register
  ], NodeFlipImageVertical);

  // src/app/FileNodeElement.ts
  var FileNodeElement = class extends NodeElement {
    constructor() {
      super();
      this.appearsInAddGUI = false;
    }
  };

  // src/app/UploadManager.ts
  var UploadManager = class {
    dragPreview;
    constructor() {
      this.dragPreview = $("#dragPreview");
    }
    /**
    * Show the preview node which follows dragged files, and handle reading in files which are dropped.
    * @param type A string representing the name of the event to handle - e.g. "dragenter", "dragover", "dragleave" or "drop".
    * @param event The event data.
    */
    handleDrag(type, event) {
      event.preventDefault();
      event.stopPropagation();
      if (type == "dragenter") {
        this.dragPreview.style.display = "block";
        $("#helperText").style.display = "none";
        application.main.classList.add("preventInteraction");
      }
      if (type == "dragenter" || type == "dragover") {
        this.dragPreview.style.left = event.clientX - 103 + "px";
        this.dragPreview.style.top = event.clientY - 82 + "px";
      } else if (type == "dragleave") {
        this.resetDraggingGUI();
      } else if (type == "drop") {
        let file = event.dataTransfer.files[0];
        let reader = new FileReader();
        reader.onloadend = () => {
          let bytes = new Uint8Array(reader.result);
          let magicNumber = this.getMagicNumber(bytes);
          let contentType = file.type;
          let extension = file.name.split(".").pop().toLowerCase();
          let bestMatch = 0;
          let clazz = null;
          let interpretedContentType;
          for (let handler of fileHandlerRegistry) {
            let typeInfo = handler[0];
            let matches = 0;
            if (typeInfo[0] != null && typeInfo[0].indexOf(magicNumber) > -1)
              matches++;
            if (typeInfo[1] != null && typeInfo[1].indexOf(contentType) > -1)
              matches++;
            if (typeInfo[2] != null && typeInfo[2].indexOf(extension) > -1)
              matches++;
            if (matches > 0 && matches > bestMatch) {
              bestMatch = matches;
              interpretedContentType = typeInfo[1];
              clazz = handler[1];
            }
          }
          if (clazz != null) {
            let node = new clazz();
            if (node instanceof FileNodeElement) {
              let base64 = btoa(bytes.reduce((acc, val) => acc + String.fromCharCode(val), ""));
              let rect = this.dragPreview.getBoundingClientRect();
              application.addNodeFromInstance(node, rect.left, rect.top);
              node.loadFile(base64, interpretedContentType);
            }
          }
          this.resetDraggingGUI();
        };
        reader.readAsArrayBuffer(file);
      }
    }
    /**
    * The "magic number" is a unique set of bytes at the beginning of most files which specify their content type.
    * This function finds the magic number for a given file, by getting the first word of the file, converting each byte
    * from binary to a HEX number, and then converting the resulting HEX number to an integer.
    * @see {@link https://en.wikipedia.org/wiki/Magic_number_%28programming%29#In_files}
    * @param {ArrayBuffer} file The file to get the magic number for
    * @return {number} The magic number
    */
    getMagicNumber(file) {
      return parseInt(file.subarray(0, 4).reduce((acc, val) => acc + val.toString(16), ""), 16);
    }
    /**
    * Reset the dragging GUI when a file is dropped or dragged off-screen.
    */
    resetDraggingGUI() {
      $("#dragPreview").style.display = "none";
      application.main.classList.remove("preventInteraction");
      application.updateState();
    }
    static asDataURL(base64, contentType) {
      return `data:${contentType[0]};base64,${base64}`;
    }
  };

  // src/app/nodes/Image/NodeImage.ts
  var NodeImage = class extends FileNodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Image", description: "Loads an image from a file" }).addOutlet({ name: "Image", description: "The loaded image", type: new TypeImage() }).setPreview(this.outlets[0]).build();
    }
    loadFile(base64, contentType) {
      let img = new Image();
      img.src = UploadManager.asDataURL(base64, contentType);
      img.onload = () => {
        this.outlets[0].setValue(img, true);
      };
    }
    apply(resolve, _reject) {
      resolve();
    }
  };
  NodeImage = __decorateClass([
    register,
    fileFormat([2303741511], ["image/png"], ["png"]),
    fileFormat([4292411352, 4292411360, 4292411374, 4292411361], ["image/jpeg"], ["jpg", "jpeg"])
  ], NodeImage);

  // src/app/nodes/Image/NodeImageInfo.ts
  var NodeImageInfo = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Image Info", description: "Get information about an image (e.g. width and height)", path: "Image" }).addInlet({ name: "Image", description: "The image", type: new TypeImage() }).addOutlet({ name: "Width", description: "The width of the image (in pixels)", type: new TypeNumber() }).addOutlet({ name: "Height", description: "The height of the image (in pixels)", type: new TypeNumber() }).setPreview(this.inlets[0]).build();
    }
    apply(resolve, _reject) {
      let img = this.inlets[0].getValue();
      this.outlets[0].setValue(img == null ? 0 : img.width);
      this.outlets[1].setValue(img == null ? 0 : img.height);
      resolve();
    }
  };
  NodeImageInfo = __decorateClass([
    register
  ], NodeImageInfo);

  // src/app/nodes/Math/Basic/NodeAdd.ts
  var NodeAdd = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Add", description: "Adds two numbers together", path: "Maths/Basic" }).addInlet({ name: "X", description: "The first number", type: new TypeNumber() }).addInlet({ name: "Y", description: "The second number", type: new TypeNumber() }).addOutlet({ name: "Result", description: "The result of X + Y", type: new TypeNumber() }).setPreview(this.outlets[0]).build();
    }
    apply(resolve, _reject) {
      this.outlets[0].setValue(this.inlets[0].getValue() + this.inlets[1].getValue());
      resolve();
    }
  };
  NodeAdd = __decorateClass([
    register
  ], NodeAdd);

  // src/app/nodes/Math/Basic/NodeMultiply.ts
  var NodeMultiply = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Multiply", description: "Multiply two numbers", path: "Maths/Basic" }).addInlet({ name: "X", description: "The first number", type: new TypeNumber() }).addInlet({ name: "Y", description: "The second number", type: new TypeNumber() }).addOutlet({ name: "Result", description: "The result of X * Y", type: new TypeNumber() }).setPreview(this.outlets[0]).build();
    }
    apply(resolve, _reject) {
      this.outlets[0].setValue(this.inlets[0].getValue() * this.inlets[1].getValue());
      resolve();
    }
  };
  NodeMultiply = __decorateClass([
    register
  ], NodeMultiply);

  // src/app/nodes/Util/NodeDownload.ts
  var NodeDownload = class extends NodeElement {
    downloadUI;
    constructor() {
      super();
      this.downloadUI = document.createElement("div");
      this.setProperties({ name: "Download", description: "Download the result from a previous node", path: "Utility" }).addInlet({ name: "Input", description: "Something to download", type: new TypeAny() }).setPreview(this.inlets[0]).setBottomUI(this.downloadUI).build();
      this.updateDownloadUI();
    }
    apply(resolve, _reject) {
      this.updateDownloadUI();
      resolve();
    }
    updateDownloadUI() {
      this.downloadUI.innerHTML = "";
      let currentValue = this.inlets[0].getValue();
      for (let downloader of downloaders) {
        if (downloader.canAccept(currentValue)) {
          let downloadButton = document.createElement("button");
          downloadButton.classList.add("downloadButton");
          downloadButton.innerHTML = `<i class="mdi mdi-download"></i> ${downloader.getExtension()}`;
          downloadButton.onclick = () => {
            downloader.download(currentValue);
          };
          this.downloadUI.appendChild(downloadButton);
        }
      }
      if (this.downloadUI.innerHTML == "") {
        this.downloadUI.innerHTML = `<div class="noResults">No Download Methods</div>`;
      }
    }
  };
  NodeDownload = __decorateClass([
    register
  ], NodeDownload);

  // src/app/nodes/Util/NodeSplit.ts
  var NodeSplit = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Split", description: "Splits one input into two identical outputs", path: "Utility" }).addInlet({ name: "Input", description: "Something to clone", type: new TypeAny() }).addOutlet({ name: "Clone 1", description: "A clone of Input", type: new TypeAny() }).addOutlet({ name: "Clone 2", description: "A clone of Input", type: new TypeAny() }).setPreview(this.inlets[0]).build();
    }
    apply(resolve, _reject) {
      let type = this.inlets[0].getType().getOtherType();
      this.outlets[0].setValue(this.inlets[0].getValue(), false, false, type);
      this.outlets[1].setValue(this.inlets[0].getValue(), false, false, type);
      resolve();
    }
  };
  NodeSplit = __decorateClass([
    register
  ], NodeSplit);

  // src/app/ConnectionManager.ts
  var ConnectionManager = class {
    canvas;
    context;
    isDrawing = false;
    startingPoint;
    lines = [];
    constructor() {
      this.canvas = $("#lines");
      this.context = this.canvas.getContext("2d");
      this.resizeCanvas();
      window.addEventListener("resize", () => {
        this.resizeCanvas();
      });
      this.render();
    }
    /**
    * Resize the canvas by setting its internal width and height to be the same as the width and height assigned to it by CSS.
    */
    resizeCanvas() {
      let rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width;
      this.canvas.height = rect.height;
      this.context.lineCap = "round";
      this.context.lineWidth = 3;
    }
    /**
    * Start or finish making a connection between two nodes.
    * @param point A point that will be part of the connection.
    */
    makeConnection(point) {
      if (point.hasLink())
        return;
      if (this.isDrawing) {
        if (this.startingPoint.getNode() == point.getNode())
          return;
        let inlet = this.startingPoint.side == 0 /* Input */ ? this.startingPoint : point;
        let outlet = this.startingPoint.side == 1 /* Output */ ? this.startingPoint : point;
        if (inlet.side != 0 /* Input */ || outlet.side != 1 /* Output */)
          return;
        if (this.checkCircularLink(outlet.getNode(), inlet.getNode()))
          return;
        let typeError = true;
        try {
          inlet.getType().cast(outlet.getType().getValue());
          outlet.getType().cast(inlet.getType().getValue());
          typeError = false;
        } catch (e) {
        }
        if (typeError)
          return;
        this.isDrawing = false;
        outlet.setLinkedNode(inlet);
        inlet.setLinkedNode(outlet);
        outlet.updateLinkedNode();
        this.lines.push([inlet, outlet]);
      } else {
        this.isDrawing = true;
        this.startingPoint = point;
      }
    }
    /**
    * Recursively check if adding a connection would create a circular link which would crash the program.
    * Works backwards, from outlets to inlets, until either a circular link is found, or all nodes have been checked.
    * @param currentElement The current element to check.
    * @param proposedTarget The element which cannot appear in any previous links.
    * @param startingPoint If true, the current node is the starting point, so the check can be skipped.
    */
    checkCircularLink(currentElement, proposedTarget) {
      if (currentElement == proposedTarget)
        return true;
      for (let inlet of currentElement.inlets) {
        let linkedNode = inlet.getLinkedNode();
        if (linkedNode == null)
          continue;
        if (this.checkCircularLink(linkedNode.getNode(), proposedTarget))
          return true;
      }
      return false;
    }
    /**
    * Stop drawing a connection, either because the user canceled, or because the connection has now been established.
    */
    endLine() {
      this.isDrawing = false;
    }
    /**
    * Draw the connection lines to the canvas.
    */
    render() {
      let renderFunc = () => {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (let line of this.lines) {
          let gradient = this.context.createLinearGradient(line[0].x, line[0].y, line[1].x, line[1].y);
          gradient.addColorStop(0, line[0].getType().getActualHexColour());
          gradient.addColorStop(1, line[1].getType().getActualHexColour());
          this.context.strokeStyle = gradient;
          this.context.beginPath();
          this.context.moveTo(line[0].x, line[0].y);
          this.context.lineTo(line[1].x, line[1].y);
          this.context.stroke();
        }
        if (this.isDrawing) {
          this.context.strokeStyle = this.startingPoint.getType().getActualHexColour();
          this.context.beginPath();
          this.context.moveTo(this.startingPoint.x, this.startingPoint.y);
          this.context.lineTo(application.getMouseX(), application.getMouseY());
          this.context.stroke();
        }
        window.requestAnimationFrame(renderFunc);
      };
      renderFunc();
    }
    /**
    * @return `true` if the user is currently dragging out a connection line.
    */
    isDrawingLine() {
      return this.isDrawing;
    }
    /**
    * Remove any line associated with the given point from the renderer.
    * @param {ConnectionPoint} node The node to remove lines for.
    */
    removeLine(node) {
      for (let i = this.lines.length - 1; i >= 0; i--) {
        if (this.lines[i][0] == node || this.lines[i][1] == node) {
          this.lines.splice(i, 1);
        }
      }
    }
  };

  // src/app/NodeDatabase.ts
  var NodeDatabase = class {
    // Database objects are in the form
    //     {name: string, description: string, path: string[], constructor: Function}
    // There are two lookup methods: a lookup by category, and a lookup by name. Both return references to the same object.
    // e.g. [{...}, {...}]
    db = [];
    // e.g. {"Math": {"Basic": {"_nodes": [...]}, "_nodes": [...]}, "Util": {"_nodes": [...]}, "_nodes": [...]}
    dbByCategory = { "_nodes": [] };
    constructor() {
      for (let candidate of registry) {
        let clazz = new candidate();
        if (clazz instanceof NodeElement) {
          if (!clazz.isNodeAddable())
            continue;
          let obj = {
            name: clazz.getName(),
            description: clazz.getDescription(),
            path: clazz.getPath(),
            construct: candidate
          };
          this.db.push(obj);
          let currentLevel = this.dbByCategory;
          for (let i = 0; i < obj.path.length; i++) {
            if (!(obj.path[i] in currentLevel)) {
              let newLevel = { "_nodes": [] };
              currentLevel[obj.path[i]] = newLevel;
              currentLevel = newLevel;
            } else {
              currentLevel = currentLevel[obj.path[i]];
            }
            if (i == obj.path.length - 1)
              currentLevel["_nodes"].push(obj);
          }
        } else {
          console.warn(`@register should only be used on classes that extend NodeElement! Class "${candidate.name}" either needs to extend NodeElement, or its @register decorator should be removed.`);
        }
      }
    }
    /**
    * Display the add node UI at the mouse pointer.
    * From here, the user can search and browse categories of nodes.
    */
    addNodeUI() {
      let element = document.createElement("div");
      element.style.left = application.getMouseX() + "px";
      element.style.top = application.getMouseY() + "px";
      element.classList.add("addNode");
      element.onmouseup = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };
      let searchContainer = document.createElement("div");
      searchContainer.classList.add("search");
      let search = document.createElement("input");
      search.type = "text";
      search.placeholder = "Add Node...";
      searchContainer.appendChild(search);
      element.appendChild(searchContainer);
      let categoryHeader = document.createElement("div");
      categoryHeader.classList.add("categoryHeader");
      element.appendChild(categoryHeader);
      let listings = document.createElement("div");
      listings.classList.add("nodeListings");
      this.showNodeGroup([], categoryHeader, listings);
      element.appendChild(listings);
      application.main.appendChild(element);
      search.oninput = () => {
        if (search.value == "") {
          this.showNodeGroup([], categoryHeader, listings);
        } else {
          let filteredNodes = this.sortNodeList(this.db.filter((x) => x["name"].toLowerCase().includes(search.value.toLowerCase())));
          listings.innerHTML = filteredNodes.length == 0 ? `<div class="noResults">No results!</div>` : "";
          categoryHeader.innerHTML = "";
          let backButton = document.createElement("i");
          backButton.setAttribute("class", "mdi mdi-chevron-left");
          backButton.onclick = () => {
            this.showNodeGroup([], categoryHeader, listings);
            search.value = "";
          };
          categoryHeader.appendChild(backButton);
          let title = document.createElement("span");
          title.innerHTML = "Search Results";
          categoryHeader.appendChild(title);
          for (let node of filteredNodes) {
            listings.appendChild(this.createNodeListing(node["name"], node["description"], false, () => {
              this.addNode(node);
            }));
          }
        }
      };
      search.onkeyup = (event) => {
        if (event.key == "Enter" && search.value != "") {
          let firstElement = listings.firstElementChild;
          if (!firstElement.classList.contains("noResults")) {
            firstElement.click();
          }
        } else if (event.key == "Escape") {
          this.close();
        }
      };
      search.focus();
    }
    /**
    * Close all open add node GUIs.
    */
    close() {
      document.querySelectorAll(".addNode").forEach((x) => x.remove());
      application.updateState();
    }
    /**
    * Show the table of sub-groups and nodes for a given level.
    * @param {string[]} path The path to the category to show listings for, e.g. ["Math", "Basic"] to represent "Math/Basic".
    * @param {HTMLElement} listings The GUI area to add the nodes into
    */
    showNodeGroup(path, categoryHeader, listings) {
      listings.innerHTML = "";
      categoryHeader.innerHTML = "";
      if (path.length > 0) {
        let backButton = document.createElement("i");
        backButton.setAttribute("class", "mdi mdi-chevron-left");
        backButton.onclick = () => {
          this.showNodeGroup(path.slice(0, -1), categoryHeader, listings);
        };
        categoryHeader.appendChild(backButton);
      }
      let title = document.createElement("span");
      title.innerHTML = path.length == 0 ? "All Nodes" : path[path.length - 1];
      categoryHeader.appendChild(title);
      let items = path.reduce((acc, val) => acc[val], this.dbByCategory);
      let itemKeys = Object.keys(items).sort();
      let nodes = this.sortNodeList(items["_nodes"]);
      for (let key of itemKeys) {
        if (key == "_nodes")
          continue;
        let row = this.createNodeListing(key, "", true, () => {
          this.showNodeGroup([...path, key], categoryHeader, listings);
        });
        listings.appendChild(row);
      }
      for (let node of nodes) {
        listings.appendChild(this.createNodeListing(node["name"], node["description"], false, () => {
          this.addNode(node);
        }));
      }
    }
    /**
    * Create a single row in the node listings.
    * @param {string} name The name of the row.
    * @param {string} description The short description of the row, shown when the user hovers their mouse over it.
    * @param {boolean} category `true` if this is a category.
    * @param {any} clickFunction The function to call when the node is clicked.
    * This affects behaviour (e.g. clicking a node adds the node, clicking a category scrolls to that level in the UI)
    * and the interface generated (categories get an arrow drawn on the right-hand side of their row)
    */
    createNodeListing(name, description, isCategory, clickFunction) {
      let result = document.createElement("div");
      result.classList.add("nodeListing");
      result.innerHTML = name + (isCategory ? `<i class="mdi mdi-chevron-right"></i>` : ``);
      result.title = description;
      result.onclick = clickFunction;
      return result;
    }
    /**
    * Sort a list of nodes so that they are in alphabetical order
    * @param {Object[]} nodes The unsorted list
    * @return {Object[]} The sorted list
    */
    sortNodeList(nodes) {
      return nodes.sort((a, b) => {
        let aName = a["name"];
        let bName = b["name"];
        return aName == bName ? 0 : aName < bName ? -1 : 1;
      });
    }
    addNode(node) {
      let rect = $(".addNode").getBoundingClientRect();
      application.addNode(node["construct"], rect.left, rect.top);
    }
  };

  // src/app/downloaders/index.ts
  var downloaders_exports = {};
  __export(downloaders_exports, {
    DownloaderImages: () => DownloaderImages,
    DownloaderJPEG: () => DownloaderJPEG,
    DownloaderPNG: () => DownloaderPNG,
    DownloaderText: () => DownloaderText
  });

  // src/app/Downloader.ts
  var Downloader = class {
    downloadDataURL(dataURL) {
      let link = document.createElement("a");
      link.download = "download" + this.getExtension();
      link.href = dataURL;
      link.target = "_blank";
      link.click();
    }
  };

  // src/app/downloaders/BasicImageDownloader.ts
  var DownloaderImages = class extends Downloader {
    canAccept(data) {
      return data instanceof Image;
    }
    download(data) {
      let img = data;
      let canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      let ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      this.downloadDataURL(canvas.toDataURL("image/" + this.getExtension().slice(1).toLowerCase()));
    }
  };
  var DownloaderPNG = class extends DownloaderImages {
    getExtension() {
      return ".PNG";
    }
  };
  DownloaderPNG = __decorateClass([
    downloadStrategy
  ], DownloaderPNG);
  var DownloaderJPEG = class extends DownloaderImages {
    getExtension() {
      return ".JPEG";
    }
  };
  DownloaderJPEG = __decorateClass([
    downloadStrategy
  ], DownloaderJPEG);

  // src/app/downloaders/DownloaderText.ts
  var DownloaderText = class extends Downloader {
    canAccept(data) {
      return typeof data == "string" || typeof data == "number";
    }
    download(data) {
      this.downloadDataURL("data:text/plain;charset=UTF-8," + encodeURIComponent(data));
    }
    getExtension() {
      return ".TXT";
    }
  };
  DownloaderText = __decorateClass([
    downloadStrategy
  ], DownloaderText);

  // src/app/Pipeline.ts
  function nop(_item) {
  }
  nop(downloaders_exports);
  nop(previews_exports);
  nop(nodes_exports);
  nop(types_exports);
  var Pipeline = class {
    main;
    connections;
    nodeDatabase;
    uploadManager;
    toAdd = NodeAdd;
    draggingNode = null;
    mouseX;
    mouseY;
    nodes = [];
    constructor() {
      this.main = $("#main");
      this.connections = new ConnectionManager();
      this.nodeDatabase = new NodeDatabase();
      this.uploadManager = new UploadManager();
      this.main.ondblclick = (event) => {
        this.showAddNodeGUI(event);
      };
      window.onmousemove = (event) => {
        this.mouseX = event.clientX;
        this.mouseY = event.clientY;
        if (this.draggingNode != null) {
          this.draggingNode.getElement().style.left = this.mouseX - this.draggingNode.dragOffsetX + "px";
          this.draggingNode.getElement().style.top = this.mouseY - this.draggingNode.dragOffsetY + "px";
          this.draggingNode.updatePlugPositions();
        }
      };
      window.onmouseup = (event) => {
        this.draggingNode = null;
        this.nodeDatabase.close();
        if (this.connections.isDrawingLine()) {
          this.connections.endLine();
          this.showAddNodeGUI(event);
        }
      };
      window.onwheel = (event) => {
        event.stopPropagation();
        let topCheck = false;
        let leftCheck = false;
        let bottomCheck = false;
        let rightCheck = false;
        this.nodes.forEach((node) => {
          const element = node.getElement();
          const rect = element.getBoundingClientRect();
          const top = parseInt(element.style.top) + event.deltaY;
          const left = parseInt(element.style.left) + event.deltaX;
          if (top + rect.height < 0)
            topCheck = true;
          if (left + rect.width < 0)
            leftCheck = true;
          if (rect.x > window.innerWidth)
            rightCheck = true;
          if (rect.y > window.innerHeight)
            bottomCheck = true;
          element.style.top = top + "px";
          element.style.left = left + "px";
          node.updatePlugPositions();
        });
        $("#indicator-top").style.display = topCheck ? "block" : "none";
        $("#indicator-right").style.display = rightCheck ? "block" : "none";
        $("#indicator-bottom").style.display = bottomCheck ? "block" : "none";
        $("#indicator-left").style.display = leftCheck ? "block" : "none";
      };
      window.oncontextmenu = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };
      ["dragenter", "dragover", "dragleave", "drop"].forEach((type) => {
        window.addEventListener(type, (event) => {
          this.uploadManager.handleDrag(type, event);
        }, false);
      });
    }
    showAddNodeGUI(event) {
      if (event.srcElement == this.main) {
        this.nodeDatabase.addNodeUI();
        this.updateState();
      }
    }
    updateState() {
      $("#helperText").style.display = this.main.childElementCount == 0 ? "block" : "none";
    }
    /**
    * Add a node to the document, and closes the add node dialog
    * @param {any} constructor A constructor for a NodeElement.
    * @param {number} x The X position of the node's top-left corner.
    * @param {number} y The Y position of the node's top-left corner.
    * @return {NodeElement} The node that was added.
    */
    addNode(constructor, x, y) {
      let node = new constructor();
      this.addNodeFromInstance(node, x, y);
      return node;
    }
    /**
    * Add a node that has already been instantiated.
    * @param {NodeElement} node The node to add.
    * @param {number} x The X position of the node's top-left corner.
    * @param {number} y The Y position of the node's top-left corner.
    */
    addNodeFromInstance(node, x, y) {
      this.nodes.push(node);
      let element = node.getElement();
      element.style.left = x + "px";
      element.style.top = y + "px";
      this.main.appendChild(element);
      node.setupPreview();
      this.updateState();
      this.nodeDatabase.close();
      node.updatePlugPositions();
    }
    /**
    * Get the current X position of the mouse.
    */
    getMouseX() {
      return this.mouseX;
    }
    /**
    * Get the current Y position of the mouse.
    */
    getMouseY() {
      return this.mouseY;
    }
  };
  var application;
  window.onload = () => {
    application = new Pipeline();
  };
  function querySelector(selector) {
    return document.querySelector(selector);
  }
  window.$ = querySelector;
})();
