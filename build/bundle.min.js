(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };

  // src/app/nodes/index.ts
  var nodes_exports = {};
  __export(nodes_exports, {
    NodeAdd: () => NodeAdd,
    NodeBrightness: () => NodeBrightness,
    NodeChannels: () => NodeChannels,
    NodeCrop: () => NodeCrop,
    NodeDownload: () => NodeDownload,
    NodeFlipImageHorizontal: () => NodeFlipImageHorizontal,
    NodeFlipImageVertical: () => NodeFlipImageVertical,
    NodeGrayscale: () => NodeGrayscale,
    NodeHueRotate: () => NodeHueRotate,
    NodeImage: () => NodeImage,
    NodeImageTransformation: () => NodeImageTransformation,
    NodeInvert: () => NodeInvert,
    NodeMultiply: () => NodeMultiply,
    NodeSplit: () => NodeSplit,
    NodeTakePhoto: () => NodeTakePhoto,
    NodeThreshold: () => NodeThreshold
  });

  // src/app/types/index.ts
  var types_exports = {};
  __export(types_exports, {
    TypeAny: () => TypeAny,
    TypeImage: () => TypeImage,
    TypeNumber: () => TypeNumber,
    TypeUnknown: () => TypeUnknown
  });

  // src/app/DataType.ts
  var DataType = class {
    value;
    control;
    constructor(initialValue = null) {
      this.value = initialValue == null ? this.defaultValue() : this.cast(initialValue);
    }
    canCast(other) {
      try {
        this.cast(other.getValue());
        return true;
      } catch (e) {
        return false;
      }
    }
    getValue() {
      return this.value;
    }
    setValue(newValue, _type) {
      this.value = this.cast(newValue);
    }
    getActualHexColour() {
      return this.getHexColour();
    }
    doPreviewSetup(_element) {
    }
    updateControl(_disabled, _value) {
    }
    doPreviewRender(_element) {
    }
  };

  // src/app/types/TypeUnknown.ts
  var TypeUnknown = class extends DataType {
    cast(other) {
      return other;
    }
    defaultValue() {
      return null;
    }
    getHexColour() {
      return "#FFC107";
    }
    getName() {
      return "Anything";
    }
    makeControl(_point, _disabled) {
      return document.createElement("span");
    }
    doPreviewRender(element) {
      element.innerHTML = `<div class="previewEmpty"></div>`;
    }
  };

  // src/app/types/TypeAny.ts
  var TypeAny = class extends DataType {
    otherType = new TypeUnknown();
    cast(other) {
      return other;
    }
    defaultValue() {
      return null;
    }
    getActualHexColour() {
      return "#FFC107";
    }
    makeControl(_point, _disabled) {
      this.control = document.createElement("span");
      this.changeControlText();
      return this.control;
    }
    setValue(newValue, type) {
      super.setValue(newValue, type);
      this.otherType = type;
      this.changeControlText();
    }
    doPreviewRender(element) {
      element.innerHTML = "";
      element.setAttribute("class", "preview");
      this.otherType.doPreviewSetup(element);
      this.otherType.doPreviewRender(element);
    }
    getHexColour() {
      return this.otherType.getHexColour();
    }
    getName() {
      return this.otherType.getName();
    }
    changeControlText() {
      this.control.innerHTML = this.getName();
      this.control.style.color = this.getHexColour();
    }
    getOtherType() {
      return this.otherType;
    }
  };

  // src/app/types/TypeImage.ts
  var TypeImage = class extends DataType {
    cast(other) {
      if (other == null)
        return other;
      if (!(other instanceof Image))
        throw new TypeError("Could not convert to an image!");
      if (!other.complete || other.naturalHeight == 0)
        return null;
      return other;
    }
    defaultValue() {
      return null;
    }
    getHexColour() {
      return "#E91E63";
    }
    getName() {
      return "Image";
    }
    makeControl(_point, disabled) {
      this.control = document.createElement("span");
      this.control.innerHTML = this.makeImageDescription(null);
      this.control.style.color = this.getHexColour();
      if (disabled)
        this.control.classList.add("disabledControl");
      return this.control;
    }
    updateControl(disabled, value) {
      this.control.setAttribute("class", disabled ? "disabledControl" : "");
      this.control.innerHTML = this.makeImageDescription(value);
    }
    makeImageDescription(img) {
      return `<i class="mdi mdi-file-image"></i> ${img == null ? "No Image" : `Image (${img.width} &times; ${img.height})`}`;
    }
    doPreviewSetup(element) {
      element.classList.add("previewImage");
    }
    doPreviewRender(element) {
      let img = this.getValue();
      element.innerHTML = "";
      if (img == null) {
        element.innerHTML = `<div class="previewEmpty"></div>`;
      } else {
        let displayImg = new Image();
        displayImg.src = img.src;
        displayImg.draggable = false;
        element.appendChild(displayImg);
      }
    }
    performTransformation(transformation) {
      let img = this.getValue();
      if (img == null)
        return null;
      let canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      let ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      transformation(canvas, ctx, img);
      let newImg = new Image();
      newImg.src = canvas.toDataURL("image/png");
      return newImg;
    }
  };

  // src/app/types/TypeNumber.ts
  var TypeNumber = class extends DataType {
    cast(other) {
      if (other === true || other === false)
        return other + 0;
      if (other === "" || other == null)
        return this.defaultValue();
      let number = parseFloat(other);
      if (isNaN(number))
        throw new TypeError("Could not convert to a number!");
      return number;
    }
    defaultValue() {
      return 0;
    }
    getHexColour() {
      return "#03A9F4";
    }
    getName() {
      return "Number";
    }
    makeControl(point, disabled) {
      let input = document.createElement("input");
      input.type = "number";
      input.value = this.getValue();
      input.disabled = disabled;
      input.oninput = () => {
        point.setValue(input.value, true);
      };
      input.onblur = () => {
        input.value = this.getValue();
      };
      this.control = input;
      return input;
    }
    updateControl(disabled, value) {
      let input = this.control;
      input.disabled = disabled;
      input.value = value;
    }
    doPreviewSetup(element) {
      element.classList.add("previewNumber");
    }
    doPreviewRender(element) {
      element.innerHTML = `<div>${this.getValue().toLocaleString("en-US")}</div>`;
    }
  };

  // src/app/IOSide.ts
  var IOSide = /* @__PURE__ */ ((IOSide2) => {
    IOSide2[IOSide2["Input"] = 0] = "Input";
    IOSide2[IOSide2["Output"] = 1] = "Output";
    return IOSide2;
  })(IOSide || {});

  // src/app/ConnectionPoint.ts
  var ConnectionPoint = class {
    name;
    description;
    type;
    node;
    link = null;
    x;
    y;
    side;
    constructor(name, description, type, node) {
      this.name = name;
      this.description = description;
      this.type = type;
      this.node = node;
    }
    getName() {
      return this.name;
    }
    getDescription() {
      return this.description;
    }
    setValue(newValue, updateNode = false, updateInlets = false, otherType = null) {
      let type = new TypeUnknown();
      if (otherType != null)
        type = otherType;
      else if (this.side == 0 /* Input */ && this.hasLink())
        type = this.link.getType();
      this.type.setValue(newValue, type);
      if (updateNode)
        this.node.update(updateInlets);
    }
    getValue() {
      return this.type.getValue();
    }
    getType() {
      return this.type;
    }
    updateLinkedNode() {
      if (this.link != null) {
        this.link.setValue(this.getValue(), true, true);
      }
    }
    setLinkedNode(link) {
      this.link = link;
    }
    getLinkedNode() {
      return this.link;
    }
    hasLink() {
      return this.link != null;
    }
    getNode() {
      return this.node;
    }
  };

  // src/app/previews/index.ts
  var previews_exports = {};
  __export(previews_exports, {
    CameraFeedState: () => CameraFeedState,
    PreviewConnectionPoint: () => PreviewConnectionPoint,
    PreviewCrop: () => PreviewCrop,
    PreviewFromCamera: () => PreviewFromCamera
  });

  // src/app/previews/PreviewConnectionPoint.ts
  var PreviewConnectionPoint = class {
    point;
    element;
    constructor(point) {
      this.point = point;
    }
    setup(element) {
      this.element = element;
      this.point.getType().doPreviewSetup(element);
    }
    render() {
      this.point.getType().doPreviewRender(this.element);
      this.point.getNode().updatePlugPositions();
    }
  };

  // src/app/previews/PreviewCrop.ts
  var PreviewCrop = class {
    node;
    element;
    canvas = null;
    constructor(node) {
      this.node = node;
    }
    setup(element) {
      this.element = element;
      this.element.classList.add("previewCrop");
    }
    render() {
      let img = this.node.inlets[0].getValue();
      if (img == null) {
        this.element.innerHTML = `<div class="previewEmpty"></div>`;
        this.canvas = null;
      } else {
        if (this.canvas == null) {
          this.element.innerHTML = "";
          let displayImg = new Image();
          displayImg.src = img.src;
          displayImg.draggable = false;
          this.element.appendChild(displayImg);
          this.canvas = document.createElement("canvas");
          this.element.appendChild(this.canvas);
        }
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        let x0 = this.node.inlets[1].getValue();
        let y0 = this.node.inlets[2].getValue();
        let x1 = this.node.inlets[3].getValue();
        let y1 = this.node.inlets[4].getValue();
        let ctx = this.canvas.getContext("2d");
        ctx.rect(0, 0, this.canvas.width, this.canvas.height);
        ctx.moveTo(x0, y0);
        ctx.rect(x0, y0, x1 - x0, y1 - y0);
        ctx.fillStyle = "#000B";
        ctx.fill("evenodd");
      }
      this.node.updatePlugPositions();
    }
  };

  // src/app/previews/PreviewFromCamera.ts
  var PreviewFromCamera = class {
    point;
    element;
    live = true;
    stream;
    video;
    constructor(point) {
      this.point = point;
    }
    setup(element) {
      this.element = element;
      this.element.classList.add("previewVideo");
      this.startLiveFeed();
    }
    render() {
    }
    takePhoto() {
      if (this.live) {
        let rect = this.video.getBoundingClientRect();
        let canvas = document.createElement("canvas");
        canvas.width = this.video.videoWidth;
        canvas.height = this.video.videoHeight;
        let ctx = canvas.getContext("2d");
        ctx.drawImage(this.video, 0, 0);
        let img = new Image();
        img.src = canvas.toDataURL("image/png");
        img.onload = () => {
          this.point.setValue(img, true);
        };
        this.element.innerHTML = "";
        canvas.setAttribute("style", `width:${rect.width}px; height:${rect.height}px;`);
        this.element.appendChild(canvas);
        this.endStream();
        this.point.getNode().updatePlugPositions();
        return CameraFeedState.STILL;
      } else {
        let rect = this.element.getBoundingClientRect();
        this.element.style.width = rect.width + "px";
        this.element.style.height = rect.height - 1 + "px";
        this.live = true;
        this.startLiveFeed();
        return CameraFeedState.LIVE;
      }
    }
    endStream() {
      this.stream.getTracks().forEach((x) => x.stop());
      this.live = false;
    }
    startLiveFeed() {
      if (this.live) {
        this.video = document.createElement("video");
        this.video.autoplay = true;
        this.video.width = 300;
        this.element.innerHTML = "";
        this.element.appendChild(this.video);
        this.point.getNode().updatePlugPositions();
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          this.stream = stream;
          this.video.srcObject = this.stream;
          this.video.onplaying = () => {
            this.point.getNode().updatePlugPositions();
          };
        });
      }
    }
  };
  var CameraFeedState = /* @__PURE__ */ ((CameraFeedState2) => {
    CameraFeedState2[CameraFeedState2["LIVE"] = 0] = "LIVE";
    CameraFeedState2[CameraFeedState2["STILL"] = 1] = "STILL";
    return CameraFeedState2;
  })(CameraFeedState || {});

  // src/app/utils/Angles.ts
  function radians(degrees) {
    return degrees * Math.PI / 180;
  }

  // src/app/utils/IterateEnum.ts
  function* iterateEnum(enumerable) {
    for (let i in enumerable) {
      if (isNaN(parseFloat(i)))
        yield enumerable[i];
    }
  }

  // src/app/utils/Math.ts
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  // src/app/NodeElement.ts
  var NodeElement = class {
    inlets = [];
    outlets = [];
    dragOffsetX;
    dragOffsetY;
    name = "";
    description = "No summary available.";
    help = "No help available.";
    path = ["Misc"];
    appearsInAddGUI = true;
    topUI = null;
    bottomUI = null;
    preview;
    element;
    previewPane;
    setProperties(properties) {
      if ("name" in properties)
        this.name = properties.name;
      if ("description" in properties)
        this.description = properties.description;
      if ("help" in properties)
        this.help = properties.help;
      if ("path" in properties)
        this.path = (properties.path || "Misc").replace(/\/$/, "").split("/");
      return this;
    }
    addInlet(properties) {
      this.inlets.push(new ConnectionPoint(properties.name, properties.description || "", properties.type, this));
      return this;
    }
    addOutlet(properties) {
      this.outlets.push(new ConnectionPoint(properties.name, properties.description || "", properties.type, this));
      return this;
    }
    setPreview(preview) {
      if (preview instanceof ConnectionPoint)
        this.preview = new PreviewConnectionPoint(preview);
      else
        this.preview = preview;
      return this;
    }
    setTopUI(ui) {
      this.topUI = ui;
      return this;
    }
    setBottomUI(ui) {
      this.bottomUI = ui;
      return this;
    }
    hideInAddGUI() {
      this.appearsInAddGUI = false;
      return this;
    }
    showInAddGUI() {
      this.appearsInAddGUI = true;
      return this;
    }
    build() {
      if (this.name == "") {
        throw new Error("All nodes must declare a name!");
      }
      this.inlets.forEach((x) => {
        x.side = 0 /* Input */;
      });
      this.outlets.forEach((x) => {
        x.side = 1 /* Output */;
      });
      this.element = document.createElement("div");
      this.element.classList.add("node");
      let title = document.createElement("div");
      title.classList.add("title");
      let deleteButton = document.createElement("div");
      deleteButton.innerHTML = `<i class="mdi mdi-delete"></i>`;
      deleteButton.classList.add("nodeDelete");
      deleteButton.title = "Delete Node";
      deleteButton.onclick = () => {
        this.onBeforeDelete();
        for (let inlet of this.inlets) {
          if (inlet.hasLink()) {
            inlet.getLinkedNode().setLinkedNode(null);
            application.connections.removeLine(inlet);
          }
        }
        for (let outlet of this.outlets) {
          if (outlet.hasLink()) {
            let linkedNode = outlet.getLinkedNode();
            linkedNode.setLinkedNode(null);
            linkedNode.setValue(linkedNode.getType().defaultValue(), true, true);
            application.connections.removeLine(outlet);
          }
        }
        this.element.remove();
        application.updateState();
      };
      title.appendChild(deleteButton);
      title.appendChild(document.createTextNode(this.name));
      title.onmousedown = () => {
        let rect = title.getBoundingClientRect();
        this.dragOffsetX = application.getMouseX() - rect.left;
        this.dragOffsetY = application.getMouseY() - rect.top;
        application.draggingNode = this;
      };
      this.element.appendChild(title);
      this.previewPane = document.createElement("div");
      this.previewPane.classList.add("preview");
      this.element.appendChild(this.previewPane);
      if (this.topUI != null) {
        this.element.appendChild(this.topUI);
      }
      let patchboard = document.createElement("table");
      let points = [this.inlets, this.outlets];
      for (let side of iterateEnum(IOSide)) {
        for (let point of points[side]) {
          let empty = document.createElement("td");
          let plugColumn = document.createElement("td");
          let plug = document.createElement("div");
          plug.classList.add("plug");
          plug.style.borderColor = point.getType().getActualHexColour();
          plug.addEventListener("mousedown", () => {
            application.connections.makeConnection(point);
          });
          plug.addEventListener("mouseup", () => {
            application.connections.makeConnection(point);
          });
          plugColumn.appendChild(plug);
          let label = document.createElement("td");
          label.title = point.getDescription();
          label.innerText = point.getName() + ":";
          let control = document.createElement("td");
          control.appendChild(point.getType().makeControl(point, side == 1 /* Output */));
          let row = document.createElement("tr");
          row.appendChild(side == 0 /* Input */ ? plugColumn : empty);
          row.appendChild(label);
          row.appendChild(control);
          row.appendChild(side == 1 /* Output */ ? plugColumn : empty);
          patchboard.appendChild(row);
        }
        if (side == 0 /* Input */) {
          let divider = document.createElement("tr");
          divider.innerHTML = `<td colspan="4"><div class="divider"></div></td>`;
          patchboard.appendChild(divider);
        }
      }
      this.element.appendChild(patchboard);
      if (this.bottomUI != null) {
        this.element.appendChild(this.bottomUI);
      }
    }
    updatePlugPositions() {
      let points = [this.inlets, this.outlets];
      let plugs = this.element.querySelectorAll(".plug");
      if (plugs.length == 0)
        return;
      for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points[i].length; j++) {
          let point = points[i][j];
          let rect = plugs[i * points[0].length + j].getBoundingClientRect();
          point.x = rect.left + rect.width / 2;
          point.y = rect.top + rect.height / 2;
        }
      }
    }
    update(updateInlets = false) {
      new Promise((resolve, reject) => {
        this.apply(resolve, reject);
      }).then(() => {
        this.preview.render();
        if (updateInlets) {
          for (let inlet of this.inlets) {
            inlet.getType().updateControl(inlet.hasLink(), inlet.getValue());
          }
        }
        for (let outlet of this.outlets) {
          outlet.updateLinkedNode();
          outlet.getType().updateControl(true, outlet.getValue());
        }
      }).catch(() => {
      });
    }
    setupPreview() {
      this.preview.setup(this.previewPane);
      this.preview.render();
    }
    onBeforeDelete() {
    }
    getElement() {
      return this.element;
    }
    getName() {
      return this.name;
    }
    getDescription() {
      return this.description;
    }
    getHelp() {
      return this.help;
    }
    getPath() {
      return this.path;
    }
    isNodeAddable() {
      return this.appearsInAddGUI;
    }
  };

  // src/app/Registry.ts
  var registry;
  var fileHandlerRegistry;
  var downloaders;
  function register(constructor) {
    if (registry == void 0)
      registry = [];
    registry.push(constructor);
  }
  function fileFormat(magicNumbers, contentType, extension) {
    return (constructor) => {
      if (fileHandlerRegistry == void 0)
        fileHandlerRegistry = [];
      fileHandlerRegistry.push([[magicNumbers, contentType, extension], constructor]);
    };
  }
  function downloadStrategy(constructor) {
    if (downloaders == void 0)
      downloaders = [];
    downloaders.push(new constructor());
  }

  // src/app/nodes/Image/Creation/NodeTakePhoto.ts
  var NodeTakePhoto = class extends NodeElement {
    constructor() {
      super();
      let takePhotoButton = document.createElement("div");
      takePhotoButton.classList.add("liveMediaButton");
      takePhotoButton.innerHTML = `<i class="mdi mdi-camera"></i>`;
      takePhotoButton.onclick = () => {
        let status = this.preview.takePhoto();
        takePhotoButton.innerHTML = `<i class="mdi mdi-${status == 0 /* LIVE */ ? "camera" : "refresh"}"></i>`;
      };
      this.setProperties({ name: "Take Photo", description: "Take a photo using your webcam", path: "Image/Creation" }).addOutlet({ name: "Photo", description: "The photo", type: new TypeImage() }).setPreview(new PreviewFromCamera(this.outlets[0])).setTopUI(takePhotoButton).build();
    }
    apply(resolve, _reject) {
      resolve();
    }
    onBeforeDelete() {
      this.preview.endStream();
    }
  };
  NodeTakePhoto = __decorateClass([
    register
  ], NodeTakePhoto);

  // src/app/nodes/Image/NodeImageTransformation.ts
  var NodeImageTransformation = class extends NodeElement {
    constructor(name, description, subfolder = "") {
      super();
      this.setProperties({ name, description, path: "Image" + subfolder }).addInlet({ name: "Image", description: "The initial image", type: new TypeImage() }).addOutlet({ name: "Output", description: "The transformed image", type: new TypeImage() }).setPreview(this.outlets[0]).build();
    }
    apply(resolve, _reject) {
      let img = this.inlets[0].getType().performTransformation(this.transformation);
      if (img == null) {
        this.outlets[0].setValue(null);
        resolve();
      } else {
        img.onload = () => {
          this.outlets[0].setValue(img);
          resolve();
        };
      }
    }
  };

  // src/app/nodes/Image/Effects/NodeBrightness.ts
  var NodeBrightness = class extends NodeImageTransformation {
    constructor() {
      super("Brightness", "Brighten or darken an image", "/Effects");
      this.addInlet({ name: "Amount", description: "The amount to brighten (or, if negative, darken) the image by", type: new TypeNumber() }).build();
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      let amount = this.inlets[1].getValue();
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] += amount;
        pixels[i + 1] += amount;
        pixels[i + 2] += amount;
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeBrightness = __decorateClass([
    register
  ], NodeBrightness);

  // src/app/nodes/Image/Effects/NodeGrayscale.ts
  var NodeGrayscale = class extends NodeImageTransformation {
    constructor() {
      super("Grayscale", "Convert an image to black and white (grayscale)", "/Effects");
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = pixels[i + 1] = pixels[i + 2] = Math.round((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeGrayscale = __decorateClass([
    register
  ], NodeGrayscale);

  // src/app/nodes/Image/Effects/NodeHueRotate.ts
  var NodeHueRotate = class extends NodeImageTransformation {
    matrix;
    constructor() {
      super("Hue Rotate", "Rotate the colours of an image", "/Effects");
      this.addInlet({
        name: "Amount",
        description: "The amount to rotate the colour space",
        type: new TypeNumber()
      }).build();
      this.matrix = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
      ];
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      let amount = this.inlets[1].getValue() % 360;
      this.setHueRotation(amount);
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const rx = clamp(r * this.matrix[0][0] + g * this.matrix[0][1] + b * this.matrix[0][2], 0, 255);
        const gx = clamp(r * this.matrix[1][0] + g * this.matrix[1][1] + b * this.matrix[1][2], 0, 255);
        const bx = clamp(r * this.matrix[2][0] + g * this.matrix[2][1] + b * this.matrix[2][2], 0, 255);
        pixels[i] = rx;
        pixels[i + 1] = gx;
        pixels[i + 2] = bx;
      }
      ctx.putImageData(data, 0, 0);
    };
    setHueRotation(degrees) {
      const cosA = Math.cos(radians(degrees));
      const sinA = Math.sin(radians(degrees));
      this.matrix[0][0] = cosA + (1 - cosA) / 3;
      this.matrix[0][1] = 1 / 3 * (1 - cosA) - Math.sqrt(1 / 3) * sinA;
      this.matrix[0][2] = 1 / 3 * (1 - cosA) + Math.sqrt(1 / 3) * sinA;
      this.matrix[1][0] = 1 / 3 * (1 - cosA) + Math.sqrt(1 / 3) * sinA;
      this.matrix[1][1] = cosA + 1 / 3 * (1 - cosA);
      this.matrix[1][2] = 1 / 3 * (1 - cosA) - Math.sqrt(1 / 3) * sinA;
      this.matrix[2][0] = 1 / 3 * (1 - cosA) - Math.sqrt(1 / 3) * sinA;
      this.matrix[2][1] = 1 / 3 * (1 - cosA) + Math.sqrt(1 / 3) * sinA;
      this.matrix[2][2] = cosA + 1 / 3 * (1 - cosA);
    }
  };
  NodeHueRotate = __decorateClass([
    register
  ], NodeHueRotate);

  // src/app/nodes/Image/Effects/NodeInvert.ts
  var NodeInvert = class extends NodeImageTransformation {
    constructor() {
      super("Invert", "Invert the colours of the image", "/Effects");
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 255 - pixels[i];
        pixels[i + 1] = 255 - pixels[i + 1];
        pixels[i + 2] = 255 - pixels[i + 2];
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeInvert = __decorateClass([
    register
  ], NodeInvert);

  // src/app/nodes/Image/Effects/NodeThreshold.ts
  var NodeThreshold = class extends NodeImageTransformation {
    constructor() {
      super("Threshold", "Threshold an image - e.g. every pixel under the threshold value is black, every pixel over it is white", "/Effects");
      let initialValue = new TypeNumber();
      initialValue.setValue(128, null);
      this.addInlet({ name: "Threshold", description: "The threshold value", type: initialValue }).build();
    }
    transformation = (canvas, ctx, _img) => {
      let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let pixels = data.data;
      let threshold = this.inlets[1].getValue();
      for (let i = 0; i < pixels.length; i += 4) {
        let avg = Math.round((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
        pixels[i] = pixels[i + 1] = pixels[i + 2] = avg < threshold ? 0 : 255;
      }
      ctx.putImageData(data, 0, 0);
    };
  };
  NodeThreshold = __decorateClass([
    register
  ], NodeThreshold);

  // src/app/nodes/Image/NodeChannels.ts
  var NodeChannels = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Channels", description: "Split an image into its red, green and blue channels", path: "Image" }).addInlet({ name: "Image", description: "The initial image", type: new TypeImage() }).addOutlet({ name: "Red", description: "The red channel", type: new TypeImage() }).addOutlet({ name: "Green", description: "The green channel", type: new TypeImage() }).addOutlet({ name: "Blue", description: "The blue channel", type: new TypeImage() }).setPreview(this.inlets[0]).build();
    }
    apply(resolve, reject) {
      let imgType = this.inlets[0].getType();
      let img = this.inlets[0].getValue();
      let channelOutlets = this.outlets;
      console.log(channelOutlets);
      if (img == null) {
        this.outlets[0].setValue(null);
        this.outlets[1].setValue(null);
        this.outlets[2].setValue(null);
      } else {
        let loaded = 0;
        for (let i = 0; i < 3; i++) {
          let newImg = imgType.performTransformation((canvas, ctx, _img) => {
            let data = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let pixels = data.data;
            for (let j = 0; j < pixels.length; j += 4) {
              let colour = pixels[j + i];
              pixels[j] = pixels[j + 1] = pixels[j + 2] = 0;
              pixels[j + i] = colour;
            }
            ctx.putImageData(data, 0, 0);
          });
          newImg.onload = () => {
            channelOutlets[i].setValue(newImg);
            if (++loaded == 3) {
              resolve();
            }
          };
        }
      }
    }
  };
  NodeChannels = __decorateClass([
    register
  ], NodeChannels);

  // src/app/nodes/Image/NodeCrop.ts
  var NodeCrop = class extends NodeImageTransformation {
    constructor() {
      super("Crop", "Crop an image");
      this.addInlet({ name: "Top-Left X", description: "The X (horizontal) position of crop rectangle's top-left corner", type: new TypeNumber() }).addInlet({ name: "Top-Left Y", description: "The Y (vertical) position of crop rectangle's top-left corner", type: new TypeNumber() }).addInlet({ name: "Bottom-Right X", description: "The X (horizontal) position of crop rectangle's bottom-right corner", type: new TypeNumber() }).addInlet({ name: "Bottom-Right Y", description: "The Y (vertical) position of crop rectangle's bottom-right corner", type: new TypeNumber() }).setPreview(new PreviewCrop(this)).build();
    }
    transformation = (canvas, ctx, img) => {
      if (img == null)
        return;
      if (this.inlets[3].getValue() == 0 && this.inlets[4].getValue() == 0) {
        this.inlets[3].setValue(img.width);
        this.inlets[4].setValue(img.height);
      }
      let x0 = this.inlets[1].getValue();
      let y0 = this.inlets[2].getValue();
      let x1 = this.inlets[3].getValue();
      let y1 = this.inlets[4].getValue();
      canvas.width = x1 - x0;
      canvas.height = y1 - y0;
      ctx.drawImage(img, x0, y0, x1 - x0, y1 - y0, 0, 0, canvas.width, canvas.height);
    };
  };
  NodeCrop = __decorateClass([
    register
  ], NodeCrop);

  // src/app/nodes/Image/NodeFlipImageHorizontal.ts
  var NodeFlipImageHorizontal = class extends NodeImageTransformation {
    constructor() {
      super("Flip Image Horizontally", "Flips an image horizontally (across the X axis)");
    }
    transformation = (canvas, ctx, img) => {
      ctx.scale(-1, 1);
      ctx.drawImage(img, -canvas.width, 0);
    };
  };
  NodeFlipImageHorizontal = __decorateClass([
    register
  ], NodeFlipImageHorizontal);

  // src/app/nodes/Image/NodeFlipImageVertical.ts
  var NodeFlipImageVertical = class extends NodeImageTransformation {
    constructor() {
      super("Flip Image Vertically", "Flips an image vertically (across the Y axis)");
    }
    transformation = (canvas, ctx, img) => {
      ctx.scale(1, -1);
      ctx.drawImage(img, 0, -canvas.height);
    };
  };
  NodeFlipImageVertical = __decorateClass([
    register
  ], NodeFlipImageVertical);

  // src/app/FileNodeElement.ts
  var FileNodeElement = class extends NodeElement {
    constructor() {
      super();
      this.appearsInAddGUI = false;
    }
  };

  // src/app/UploadManager.ts
  var UploadManager = class {
    dragPreview;
    constructor() {
      this.dragPreview = $("#dragPreview");
    }
    handleDrag(type, event) {
      event.preventDefault();
      event.stopPropagation();
      if (type == "dragenter") {
        this.dragPreview.style.display = "block";
        $("#helperText").style.display = "none";
        application.main.classList.add("preventInteraction");
      }
      if (type == "dragenter" || type == "dragover") {
        this.dragPreview.style.left = event.clientX - 103 + "px";
        this.dragPreview.style.top = event.clientY - 82 + "px";
      } else if (type == "dragleave") {
        this.resetDraggingGUI();
      } else if (type == "drop") {
        let file = event.dataTransfer.files[0];
        let reader = new FileReader();
        reader.onloadend = () => {
          let bytes = new Uint8Array(reader.result);
          let magicNumber = this.getMagicNumber(bytes);
          let contentType = file.type;
          let extension = file.name.split(".").pop().toLowerCase();
          let bestMatch = 0;
          let clazz = null;
          let interpretedContentType;
          for (let handler of fileHandlerRegistry) {
            let typeInfo = handler[0];
            let matches = 0;
            if (typeInfo[0] != null && typeInfo[0].indexOf(magicNumber) > -1)
              matches++;
            if (typeInfo[1] != null && typeInfo[1].indexOf(contentType) > -1)
              matches++;
            if (typeInfo[2] != null && typeInfo[2].indexOf(extension) > -1)
              matches++;
            if (matches > 0 && matches > bestMatch) {
              bestMatch = matches;
              interpretedContentType = typeInfo[1];
              clazz = handler[1];
            }
          }
          if (clazz != null) {
            let node = new clazz();
            if (node instanceof FileNodeElement) {
              let base64 = btoa(bytes.reduce((acc, val) => acc + String.fromCharCode(val), ""));
              let rect = this.dragPreview.getBoundingClientRect();
              application.addNodeFromInstance(node, rect.left, rect.top);
              node.loadFile(base64, interpretedContentType);
            }
          }
          this.resetDraggingGUI();
        };
        reader.readAsArrayBuffer(file);
      }
    }
    getMagicNumber(file) {
      return parseInt(file.subarray(0, 4).reduce((acc, val) => acc + val.toString(16), ""), 16);
    }
    resetDraggingGUI() {
      $("#dragPreview").style.display = "none";
      application.main.classList.remove("preventInteraction");
      application.updateState();
    }
    static asDataURL(base64, contentType) {
      return `data:${contentType[0]};base64,${base64}`;
    }
  };

  // src/app/nodes/Image/NodeImage.ts
  var NodeImage = class extends FileNodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Image", description: "Loads an image from a file" }).addOutlet({ name: "Image", description: "The loaded image", type: new TypeImage() }).setPreview(this.outlets[0]).build();
    }
    loadFile(base64, contentType) {
      let img = new Image();
      img.src = UploadManager.asDataURL(base64, contentType);
      img.onload = () => {
        this.outlets[0].setValue(img, true);
      };
    }
    apply(resolve, _reject) {
      resolve();
    }
  };
  NodeImage = __decorateClass([
    register,
    fileFormat([2303741511], ["image/png"], ["png"]),
    fileFormat([4292411352, 4292411360, 4292411374, 4292411361], ["image/jpeg"], ["jpg", "jpeg"])
  ], NodeImage);

  // src/app/nodes/Image/NodeImageInfo.ts
  var NodeImageInfo = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Image Info", description: "Get information about an image (e.g. width and height)", path: "Image" }).addInlet({ name: "Image", description: "The image", type: new TypeImage() }).addOutlet({ name: "Width", description: "The width of the image (in pixels)", type: new TypeNumber() }).addOutlet({ name: "Height", description: "The height of the image (in pixels)", type: new TypeNumber() }).setPreview(this.inlets[0]).build();
    }
    apply(resolve, _reject) {
      let img = this.inlets[0].getValue();
      this.outlets[0].setValue(img == null ? 0 : img.width);
      this.outlets[1].setValue(img == null ? 0 : img.height);
      resolve();
    }
  };
  NodeImageInfo = __decorateClass([
    register
  ], NodeImageInfo);

  // src/app/nodes/Math/Basic/NodeAdd.ts
  var NodeAdd = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Add", description: "Adds two numbers together", path: "Maths/Basic" }).addInlet({ name: "X", description: "The first number", type: new TypeNumber() }).addInlet({ name: "Y", description: "The second number", type: new TypeNumber() }).addOutlet({ name: "Result", description: "The result of X + Y", type: new TypeNumber() }).setPreview(this.outlets[0]).build();
    }
    apply(resolve, _reject) {
      this.outlets[0].setValue(this.inlets[0].getValue() + this.inlets[1].getValue());
      resolve();
    }
  };
  NodeAdd = __decorateClass([
    register
  ], NodeAdd);

  // src/app/nodes/Math/Basic/NodeMultiply.ts
  var NodeMultiply = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Multiply", description: "Multiply two numbers", path: "Maths/Basic" }).addInlet({ name: "X", description: "The first number", type: new TypeNumber() }).addInlet({ name: "Y", description: "The second number", type: new TypeNumber() }).addOutlet({ name: "Result", description: "The result of X * Y", type: new TypeNumber() }).setPreview(this.outlets[0]).build();
    }
    apply(resolve, _reject) {
      this.outlets[0].setValue(this.inlets[0].getValue() * this.inlets[1].getValue());
      resolve();
    }
  };
  NodeMultiply = __decorateClass([
    register
  ], NodeMultiply);

  // src/app/nodes/Util/NodeDownload.ts
  var NodeDownload = class extends NodeElement {
    downloadUI;
    constructor() {
      super();
      this.downloadUI = document.createElement("div");
      this.setProperties({ name: "Download", description: "Download the result from a previous node", path: "Utility" }).addInlet({ name: "Input", description: "Something to download", type: new TypeAny() }).setPreview(this.inlets[0]).setBottomUI(this.downloadUI).build();
      this.updateDownloadUI();
    }
    apply(resolve, _reject) {
      this.updateDownloadUI();
      resolve();
    }
    updateDownloadUI() {
      this.downloadUI.innerHTML = "";
      let currentValue = this.inlets[0].getValue();
      for (let downloader of downloaders) {
        if (downloader.canAccept(currentValue)) {
          let downloadButton = document.createElement("button");
          downloadButton.classList.add("downloadButton");
          downloadButton.innerHTML = `<i class="mdi mdi-download"></i> ${downloader.getExtension()}`;
          downloadButton.onclick = () => {
            downloader.download(currentValue);
          };
          this.downloadUI.appendChild(downloadButton);
        }
      }
      if (this.downloadUI.innerHTML == "") {
        this.downloadUI.innerHTML = `<div class="noResults">No Download Methods</div>`;
      }
    }
  };
  NodeDownload = __decorateClass([
    register
  ], NodeDownload);

  // src/app/nodes/Util/NodeSplit.ts
  var NodeSplit = class extends NodeElement {
    constructor() {
      super();
      this.setProperties({ name: "Split", description: "Splits one input into two identical outputs", path: "Utility" }).addInlet({ name: "Input", description: "Something to clone", type: new TypeAny() }).addOutlet({ name: "Clone 1", description: "A clone of Input", type: new TypeAny() }).addOutlet({ name: "Clone 2", description: "A clone of Input", type: new TypeAny() }).setPreview(this.inlets[0]).build();
    }
    apply(resolve, _reject) {
      let type = this.inlets[0].getType().getOtherType();
      this.outlets[0].setValue(this.inlets[0].getValue(), false, false, type);
      this.outlets[1].setValue(this.inlets[0].getValue(), false, false, type);
      resolve();
    }
  };
  NodeSplit = __decorateClass([
    register
  ], NodeSplit);

  // src/app/ConnectionManager.ts
  var ConnectionManager = class {
    canvas;
    context;
    isDrawing = false;
    startingPoint;
    lines = [];
    constructor() {
      this.canvas = $("#lines");
      this.context = this.canvas.getContext("2d");
      this.resizeCanvas();
      window.addEventListener("resize", () => {
        this.resizeCanvas();
      });
      this.render();
    }
    resizeCanvas() {
      let rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width;
      this.canvas.height = rect.height;
      this.context.lineCap = "round";
      this.context.lineWidth = 3;
    }
    makeConnection(point) {
      if (point.hasLink())
        return;
      if (this.isDrawing) {
        if (this.startingPoint.getNode() == point.getNode())
          return;
        let inlet = this.startingPoint.side == 0 /* Input */ ? this.startingPoint : point;
        let outlet = this.startingPoint.side == 1 /* Output */ ? this.startingPoint : point;
        if (inlet.side != 0 /* Input */ || outlet.side != 1 /* Output */)
          return;
        if (this.checkCircularLink(outlet.getNode(), inlet.getNode()))
          return;
        let typeError = true;
        try {
          inlet.getType().cast(outlet.getType().getValue());
          outlet.getType().cast(inlet.getType().getValue());
          typeError = false;
        } catch (e) {
        }
        if (typeError)
          return;
        this.isDrawing = false;
        outlet.setLinkedNode(inlet);
        inlet.setLinkedNode(outlet);
        outlet.updateLinkedNode();
        this.lines.push([inlet, outlet]);
      } else {
        this.isDrawing = true;
        this.startingPoint = point;
      }
    }
    checkCircularLink(currentElement, proposedTarget) {
      if (currentElement == proposedTarget)
        return true;
      for (let inlet of currentElement.inlets) {
        let linkedNode = inlet.getLinkedNode();
        if (linkedNode == null)
          continue;
        if (this.checkCircularLink(linkedNode.getNode(), proposedTarget))
          return true;
      }
      return false;
    }
    endLine() {
      this.isDrawing = false;
    }
    render() {
      let renderFunc = () => {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (let line of this.lines) {
          let gradient = this.context.createLinearGradient(line[0].x, line[0].y, line[1].x, line[1].y);
          gradient.addColorStop(0, line[0].getType().getActualHexColour());
          gradient.addColorStop(1, line[1].getType().getActualHexColour());
          this.context.strokeStyle = gradient;
          this.context.beginPath();
          this.context.moveTo(line[0].x, line[0].y);
          this.context.lineTo(line[1].x, line[1].y);
          this.context.stroke();
        }
        if (this.isDrawing) {
          this.context.strokeStyle = this.startingPoint.getType().getActualHexColour();
          this.context.beginPath();
          this.context.moveTo(this.startingPoint.x, this.startingPoint.y);
          this.context.lineTo(application.getMouseX(), application.getMouseY());
          this.context.stroke();
        }
        window.requestAnimationFrame(renderFunc);
      };
      renderFunc();
    }
    isDrawingLine() {
      return this.isDrawing;
    }
    removeLine(node) {
      for (let i = this.lines.length - 1; i >= 0; i--) {
        if (this.lines[i][0] == node || this.lines[i][1] == node) {
          this.lines.splice(i, 1);
        }
      }
    }
  };

  // src/app/NodeDatabase.ts
  var NodeDatabase = class {
    db = [];
    dbByCategory = { "_nodes": [] };
    constructor() {
      for (let candidate of registry) {
        let clazz = new candidate();
        if (clazz instanceof NodeElement) {
          if (!clazz.isNodeAddable())
            continue;
          let obj = {
            name: clazz.getName(),
            description: clazz.getDescription(),
            path: clazz.getPath(),
            construct: candidate
          };
          this.db.push(obj);
          let currentLevel = this.dbByCategory;
          for (let i = 0; i < obj.path.length; i++) {
            if (!(obj.path[i] in currentLevel)) {
              let newLevel = { "_nodes": [] };
              currentLevel[obj.path[i]] = newLevel;
              currentLevel = newLevel;
            } else {
              currentLevel = currentLevel[obj.path[i]];
            }
            if (i == obj.path.length - 1)
              currentLevel["_nodes"].push(obj);
          }
        } else {
          console.warn(`@register should only be used on classes that extend NodeElement! Class "${candidate.name}" either needs to extend NodeElement, or its @register decorator should be removed.`);
        }
      }
    }
    addNodeUI() {
      let element = document.createElement("div");
      element.style.left = application.getMouseX() + "px";
      element.style.top = application.getMouseY() + "px";
      element.classList.add("addNode");
      element.onmouseup = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };
      let searchContainer = document.createElement("div");
      searchContainer.classList.add("search");
      let search = document.createElement("input");
      search.type = "text";
      search.placeholder = "Add Node...";
      searchContainer.appendChild(search);
      element.appendChild(searchContainer);
      let categoryHeader = document.createElement("div");
      categoryHeader.classList.add("categoryHeader");
      element.appendChild(categoryHeader);
      let listings = document.createElement("div");
      listings.classList.add("nodeListings");
      this.showNodeGroup([], categoryHeader, listings);
      element.appendChild(listings);
      application.main.appendChild(element);
      search.oninput = () => {
        if (search.value == "") {
          this.showNodeGroup([], categoryHeader, listings);
        } else {
          let filteredNodes = this.sortNodeList(this.db.filter((x) => x["name"].toLowerCase().includes(search.value.toLowerCase())));
          listings.innerHTML = filteredNodes.length == 0 ? `<div class="noResults">No results!</div>` : "";
          categoryHeader.innerHTML = "";
          let backButton = document.createElement("i");
          backButton.setAttribute("class", "mdi mdi-chevron-left");
          backButton.onclick = () => {
            this.showNodeGroup([], categoryHeader, listings);
            search.value = "";
          };
          categoryHeader.appendChild(backButton);
          let title = document.createElement("span");
          title.innerHTML = "Search Results";
          categoryHeader.appendChild(title);
          for (let node of filteredNodes) {
            listings.appendChild(this.createNodeListing(node["name"], node["description"], false, () => {
              this.addNode(node);
            }));
          }
        }
      };
      search.onkeyup = (event) => {
        if (event.key == "Enter" && search.value != "") {
          let firstElement = listings.firstElementChild;
          if (!firstElement.classList.contains("noResults")) {
            firstElement.click();
          }
        } else if (event.key == "Escape") {
          this.close();
        }
      };
      search.focus();
    }
    close() {
      document.querySelectorAll(".addNode").forEach((x) => x.remove());
      application.updateState();
    }
    showNodeGroup(path, categoryHeader, listings) {
      listings.innerHTML = "";
      categoryHeader.innerHTML = "";
      if (path.length > 0) {
        let backButton = document.createElement("i");
        backButton.setAttribute("class", "mdi mdi-chevron-left");
        backButton.onclick = () => {
          this.showNodeGroup(path.slice(0, -1), categoryHeader, listings);
        };
        categoryHeader.appendChild(backButton);
      }
      let title = document.createElement("span");
      title.innerHTML = path.length == 0 ? "All Nodes" : path[path.length - 1];
      categoryHeader.appendChild(title);
      let items = path.reduce((acc, val) => acc[val], this.dbByCategory);
      let itemKeys = Object.keys(items).sort();
      let nodes = this.sortNodeList(items["_nodes"]);
      for (let key of itemKeys) {
        if (key == "_nodes")
          continue;
        let row = this.createNodeListing(key, "", true, () => {
          this.showNodeGroup([...path, key], categoryHeader, listings);
        });
        listings.appendChild(row);
      }
      for (let node of nodes) {
        listings.appendChild(this.createNodeListing(node["name"], node["description"], false, () => {
          this.addNode(node);
        }));
      }
    }
    createNodeListing(name, description, isCategory, clickFunction) {
      let result = document.createElement("div");
      result.classList.add("nodeListing");
      result.innerHTML = name + (isCategory ? `<i class="mdi mdi-chevron-right"></i>` : ``);
      result.title = description;
      result.onclick = clickFunction;
      return result;
    }
    sortNodeList(nodes) {
      return nodes.sort((a, b) => {
        let aName = a["name"];
        let bName = b["name"];
        return aName == bName ? 0 : aName < bName ? -1 : 1;
      });
    }
    addNode(node) {
      let rect = $(".addNode").getBoundingClientRect();
      application.addNode(node["construct"], rect.left, rect.top);
    }
  };

  // src/app/downloaders/index.ts
  var downloaders_exports = {};
  __export(downloaders_exports, {
    DownloaderImages: () => DownloaderImages,
    DownloaderJPEG: () => DownloaderJPEG,
    DownloaderPNG: () => DownloaderPNG,
    DownloaderText: () => DownloaderText
  });

  // src/app/Downloader.ts
  var Downloader = class {
    downloadDataURL(dataURL) {
      let link = document.createElement("a");
      link.download = "download" + this.getExtension();
      link.href = dataURL;
      link.target = "_blank";
      link.click();
    }
  };

  // src/app/downloaders/BasicImageDownloader.ts
  var DownloaderImages = class extends Downloader {
    canAccept(data) {
      return data instanceof Image;
    }
    download(data) {
      let img = data;
      let canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      let ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      this.downloadDataURL(canvas.toDataURL("image/" + this.getExtension().slice(1).toLowerCase()));
    }
  };
  var DownloaderPNG = class extends DownloaderImages {
    getExtension() {
      return ".PNG";
    }
  };
  DownloaderPNG = __decorateClass([
    downloadStrategy
  ], DownloaderPNG);
  var DownloaderJPEG = class extends DownloaderImages {
    getExtension() {
      return ".JPEG";
    }
  };
  DownloaderJPEG = __decorateClass([
    downloadStrategy
  ], DownloaderJPEG);

  // src/app/downloaders/DownloaderText.ts
  var DownloaderText = class extends Downloader {
    canAccept(data) {
      return typeof data == "string" || typeof data == "number";
    }
    download(data) {
      this.downloadDataURL("data:text/plain;charset=UTF-8," + encodeURIComponent(data));
    }
    getExtension() {
      return ".TXT";
    }
  };
  DownloaderText = __decorateClass([
    downloadStrategy
  ], DownloaderText);

  // src/app/Pipeline.ts
  function nop(_item) {
  }
  nop(downloaders_exports);
  nop(previews_exports);
  nop(nodes_exports);
  nop(types_exports);
  var Pipeline = class {
    main;
    connections;
    nodeDatabase;
    uploadManager;
    toAdd = NodeAdd;
    draggingNode = null;
    mouseX;
    mouseY;
    nodes = [];
    constructor() {
      this.main = $("#main");
      this.connections = new ConnectionManager();
      this.nodeDatabase = new NodeDatabase();
      this.uploadManager = new UploadManager();
      this.main.ondblclick = (event) => {
        this.showAddNodeGUI(event);
      };
      window.onmousemove = (event) => {
        this.mouseX = event.clientX;
        this.mouseY = event.clientY;
        if (this.draggingNode != null) {
          this.draggingNode.getElement().style.left = this.mouseX - this.draggingNode.dragOffsetX + "px";
          this.draggingNode.getElement().style.top = this.mouseY - this.draggingNode.dragOffsetY + "px";
          this.draggingNode.updatePlugPositions();
        }
      };
      window.onmouseup = (event) => {
        this.draggingNode = null;
        this.nodeDatabase.close();
        if (this.connections.isDrawingLine()) {
          this.connections.endLine();
          this.showAddNodeGUI(event);
        }
      };
      window.onwheel = (event) => {
        event.stopPropagation();
      };
      window.oncontextmenu = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };
      ["dragenter", "dragover", "dragleave", "drop"].forEach((type) => {
        window.addEventListener(type, (event) => {
          this.uploadManager.handleDrag(type, event);
        }, false);
      });
    }
    showAddNodeGUI(event) {
      if (event.srcElement == this.main) {
        this.nodeDatabase.addNodeUI();
        this.updateState();
      }
    }
    updateState() {
      $("#helperText").style.display = this.main.childElementCount == 0 ? "block" : "none";
    }
    addNode(constructor, x, y) {
      let node = new constructor();
      this.addNodeFromInstance(node, x, y);
      return node;
    }
    addNodeFromInstance(node, x, y) {
      this.nodes.push(node);
      let element = node.getElement();
      element.style.left = x + "px";
      element.style.top = y + "px";
      this.main.appendChild(element);
      node.setupPreview();
      this.updateState();
      this.nodeDatabase.close();
      node.updatePlugPositions();
    }
    getMouseX() {
      return this.mouseX;
    }
    getMouseY() {
      return this.mouseY;
    }
  };
  var application;
  window.onload = () => {
    application = new Pipeline();
  };
  function querySelector(selector) {
    return document.querySelector(selector);
  }
  window.$ = querySelector;
})();
